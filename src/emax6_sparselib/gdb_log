Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
loc membase = 0x555555576210 <__libc_csu_init> "\363\017\036\372AWL\215=3+": 243 '\363', A_H_pad = 21845, tmp = 1431790173, num = -134455352, col_index_A = 0x0: Cannot access memory at address 0x0, row_index_A = 0x555555555200 <_start>: -98693133, A_tmp = 0x7fffffffd4d0: 1
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
loc membase = 0x7ffff737c020 "": 0 '\000', A_H_pad = 0, tmp = 1, num = 0, col_index_A = 0x7ffff6b35010: Cannot access memory at address 0x7ffff6b35010, row_index_A = 0x7ffff6923010: Cannot access memory at address 0x7ffff6923010, A_tmp = 0x7ffff6711010: 1065353216
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
247	  get_nanosec(0);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
 251      sum = 0;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
loc membase = 0x7ffff737c020 "": 0 '\000', A_H_pad = 0, tmp = 1, num = 0, col_index_A = 0x7ffff6b35010: Cannot access memory at address 0x7ffff6b35010, row_index_A = 0x7ffff6923010: Cannot access memory at address 0x7ffff6923010, A_tmp = 0x7ffff6711010: 1065353216
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
248	  show_nanosec();
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
 251      sum = 0;
 252      sum1 = 0;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
loc membase = 0x7ffff737c020 "": 0 '\000', A_H_pad = 0, tmp = 1, num = 0, col_index_A = 0x7ffff6b35010: Cannot access memory at address 0x7ffff6b35010, row_index_A = 0x7ffff6923010: Cannot access memory at address 0x7ffff6923010, A_tmp = 0x7ffff6711010: 1065353216
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
loc membase = 0x555555576520 <__libc_csu_init> "\363\017\036\372AWL\215=#(": 243 '\363', A_H_pad = 21845, tmp = 1431790957, num = -134455352, col_index_A = 0x0: Cannot access memory at address 0x0, row_index_A = 0x555555555200 <_start>: -98693133, A_tmp = 0x7fffffffd4d0: 1
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
loc membase = 0x7ffff737c020 "": 0 '\000', A_H_pad = 0, tmp = 1, num = 0, col_index_A = 0x7ffff6b35010: Cannot access memory at address 0x7ffff6b35010, row_index_A = 0x7ffff6923010: Cannot access memory at address 0x7ffff6923010, A_tmp = 0x7ffff6711010: 1065353216
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 21845, A_sparse = 0x7ffff7fc16a0 <_IO_2_1_stdout_>: {nnz = -72537468,col_normal_size = 0,row_normal_size = 14…, B = 0xa: Cannot access memory at address 0xa, C = 0x555555629e60: 0, B_col_size = 1431793863, params = 0x0: Cannot access memory at address 0x0
loc A_nnz = -11408, A_col_size = 32767, A_row_size = 1431790880, A_col_p = 0x5555555560b6 <reset_nanosec+96>: -532313272, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = -11408, A_col_size = 32767, A_row_size = 1431790880, A_col_p = 0x5555555560b6 <reset_nanosec+96>: -532313272, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = -11408, A_col_size = 32767, A_row_size = 1431790880, A_col_p = 0x5555555560b6 <reset_nanosec+96>: -532313272, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 32767, A_row_size = 1431790880, A_col_p = 0x5555555560b6 <reset_nanosec+96>: -532313272, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 1431790880, A_col_p = 0x5555555560b6 <reset_nanosec+96>: -532313272, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x5555555560b6 <reset_nanosec+96>: -532313272, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x0: Cannot access memory at address 0x0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x855556218: Cannot access memory at address 0x855556218, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x61ac7498: Cannot access memory at address 0x61ac7498, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x296fbf97: Cannot access memory at address 0x296fbf97, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x0: Cannot access memory at address 0x0, A_paddings = 0x5dd136b6: Cannot access memory at address 0x5dd136b6, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x0: Cannot access memory at address 0x0, A_paddings = 0x55555562c110: 0, A_margin = 0x4032bff9331b0400: Cannot access memory at address 0x4032bff9331b0400, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x0: Cannot access memory at address 0x0, A_paddings = 0x55555562c110: 0, A_margin = 0x55555562cca0: 2944, B_row_size = 21845, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x0: Cannot access memory at address 0x0, A_paddings = 0x55555562c110: 0, A_margin = 0x55555562cca0: 2944, B_row_size = 736, A_judge = -11408, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x0: Cannot access memory at address 0x0, A_paddings = 0x55555562c110: 0, A_margin = 0x55555562cca0: 2944, B_row_size = 736, A_judge = 0, NCHIP = 32767, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
─── Variables ──────────────────────────────────────────────────────────────────────────────────────────────────────────────
arg nnz = 541696, A_sparse = 0x5555556286d0: {nnz = 541696,col_normal_size = 736,row_normal_size = 736,col_p = 0x5555556…, B = 0x7ffff779e020: 1065353216, C = 0x7ffff7bc0020: 0, B_col_size = 736, params = 0x5555556286b0: {H_param = 46,W_param = 4,RMGRP_param = 8,NCHIP_param = 4}
loc A_nnz = 541696, A_col_size = 736, A_row_size = 736, A_col_p = 0x55555562b580: 736, A_nnz_col_index = 0x7ffff5eca010: 0, A_val_index_set = 0x7ffff737c020: 1065353216, A_sort_index = 0x7ffff7dd1020: 0, A_col_num = 0x0: Cannot access memory at address 0x0, A_paddings = 0x55555562c110: 0, A_margin = 0x55555562cca0: 2944, B_row_size = 736, A_judge = 0, NCHIP = 4, RMGRP = -11056, W = 32767, H = 0, A_col_H_div = 0, count = 1431802112, top = 21845, h = 1431790880, w = 21845, CHIP = 140737352782389, rofs = 93824992236032, rofs_blk = 140737488343952, cofs = 93824992236032
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
124	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
 127   int top,blk,h,w,blk_iter;
 128    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
132	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 127   int top,blk,h,w,blk_iter;
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 0
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$2 = 185
$3 = 185
$4 = 135424
$5 = 0
$6 = 0
$7 = 135424
$8 = 2944
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
warning: Source file is more recent than executable.
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
124	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
 127   int top,blk,h,w,blk_iter;
 128    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
132	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 127   int top,blk,h,w,blk_iter;
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 135424
$2 = {[0] = 2944, [1] = 2944, [2] = 2944, [3] = 2944, [4] = 0, [5] = 115521, [6] = 0, [7] = 0, [8] = 0, [9] = 0}
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
124	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
 127   int top,blk,h,w,blk_iter;
 128    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
132	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 127   int top,blk,h,w,blk_iter;
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 0
$2 = {[0] = 0, [1] = 2944, [2] = 2944, [3] = 2944}
$3 = 1
$4 = 1
$5 = 1
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
160	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
161	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
 165              }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$6 = 2
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
160	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
161	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
 165              }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 3 at 0x555555572a7b: file util/sparse_multiply.c, line 137.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:137
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
!137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
!137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
!137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$7 = 1
$8 = 0
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 3 at 0x555555572a8a: file util/sparse_multiply.c, line 138.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 2
$2 = 1
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$3 = 1
Junk after end of expression.
$4 = 4
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$5 = 6
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$6 = 8
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$7 = 10
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$8 = 12
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$9 = 42
$10 = 42
$11 = 42
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$12 = 44
$13 = 44
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$14 = 46
$15 = 0
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$16 = 46
Hardware watchpoint 4: *(float*)&C[0]
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:138
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
!138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$17 = 46
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00005555555552e9 in main at test_chipA_div.c:107
	breakpoint already hit 1 time
2       breakpoint     keep y   0x0000555555555a8e in main at test_chipA_div.c:246
	breakpoint already hit 1 time
3       breakpoint     keep y   0x0000555555572a8a in sparse_multiply_imax4 at util/sparse_multiply.c:138
	breakpoint already hit 26 times
4       hw watchpoint  keep y                      *(float*)&C[0]
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 4: *(float*)&C[0]

Old value = 46
New value = 47
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:159
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$18 = 0
$19 = 47
$20 = 0
No symbol "row_blk" in current context.
$21 = 1
$22 = 0
$23 = 184
Quit
Quit
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 4: *(float*)&C[0]

Old value = 47
New value = 48
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:161
161	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
 165              }
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$24 = 48
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 4: *(float*)&C[0]

Old value = 48
New value = 49
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:159
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$25 = 49
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 4: *(float*)&C[0]

Old value = 49
New value = 50
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:161
161	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
 165              }
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$26 = 50
Hardware watchpoint 5: *(float*)&C[0]>736
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00005555555552e9 in main at test_chipA_div.c:107
	breakpoint already hit 1 time
2       breakpoint     keep y   0x0000555555555a8e in main at test_chipA_div.c:246
	breakpoint already hit 1 time
4       hw watchpoint  keep y                      *(float*)&C[0]
	breakpoint already hit 4 times
5       hw watchpoint  keep y                      *(float*)&C[0]>736
Continuing.
[H[J[3J─── Output/messages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 5: *(float*)&C[0]>736

Old value = 0
New value = 1
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:159
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$27 = 737
$28 = 0
No symbol "rowfs_blk" in current context.
$29 = 0
$30 = 0
$31 = 8
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
124	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
 127   int top,blk,h,w,blk_iter;
 128    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
132	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 127   int top,blk,h,w,blk_iter;
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]        += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 0
Hardware watchpoint 3: *(float*)&C[0] > 736
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Watchpoint 3 deleted because the program has left the block in
which its expression is valid.
main () at test_chipA_div.c:247
247	  get_nanosec(0);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
 251      sum = 0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
warning: Source file is more recent than executable.
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
124	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
 127   int top,blk,h,w,blk_iter;
 128    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
132	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 127   int top,blk,h,w,blk_iter;
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Quit
Quit
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
118	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 113      Ull* A_margin = A_sparse->margin;
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      int B_row_size = A_sparse->col_normal_size;
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int A_judge=0;
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int B_row_min,B_row_max;
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int A_col_min,A_col_max;
 118      int NCHIP = params->NCHIP_param; 
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
124	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 119      int RMGRP = params->RMGRP_param;
 120      int W = params->W_param; 
 121      int H = params->H_param; 
 122      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 123      int pad_index;
 124      int count=0;
 125      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 126  
 127   int top,blk,h,w,blk_iter;
 128    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
132	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 127   int top,blk,h,w,blk_iter;
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128    
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    Ull CHIP;
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull rofs,rofs_blk,cofs;
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    // AもBも縦方向に格納している
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 135    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 136      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 137              for (h=0; h<H; h+=2) { // 一回で2段を表している
 138                  for (w=0; w<W; w+=2) {    // Bcol +=2
 139                  count++;
 140                  // AもBもCも縦方向に格納している。
 141                  // A  32bit val : 32bit next unit Brow
 142                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 143                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
158	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
160	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
161	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 164                }
 165              }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Hardware watchpoint 3: *(float*)&C[184]
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 3: *(float*)&C[184]

Old value = 0
New value = 185
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:159
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*A_row_size/NCHIP]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*A_row_size/NCHIP]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 185
$2 = 0
$3 = 0
$4 = 0
$5 = 135424
$6 = 1
$7 = 184
$8 = 184
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=21845, A_sparse=0x7ffff7fc16a0 <_IO_2_1_stdout_>, B=0xa, C=0x555555629e60, B_col_size=1431793863, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Hardware watchpoint 3: *(float*)&C[368*A_col_size]
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 3: *(float*)&C[368*A_col_size]

Old value = <unreadable>
New value = 0
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:106
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 3: *(float*)&C[368*A_col_size]

Old value = 0
New value = 185
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:159
159	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*A_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
 163                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 185
$2 = 135424
$3 = 2944
$4 = 2
$5 = 0
$6 = 0
$7 = 0
$8 = 2944
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Program received signal SIGSEGV, Segmentation fault.
0x0000555555572c3b in sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:158
158	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 153                  //A_indexが一度に2箇所読み出す
 154                  //rofs*2はAindexがBのsimdと同じように格納されているから
 155                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 156                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 157                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 158                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 159                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP+1]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP+1]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 162  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 2
$2 = 0
$3 = 0
$4 = {[0] = 0, [1] = 2944, [2] = 5888, [3] = 8832}
$5 = {[0] = 0, [1] = 2944, [2] = 5888, [3] = 8832, [4] = 11776}
$6 = 5888
$7 = 14199
$8 = 4.48415509e-44
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x5555555554a9: file test_chipA_div.c, line 146.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:146
146	  int* col_index_A = (int *)calloc(A_row_size*A_col_size,sizeof(int));
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 141    printf("A : %08.8x\n", A);
 142    printf("B : %08.8x\n", B);
 143    printf("C0: %08.8x\n", C0);
 144    printf("C1: %08.8x\n", C1);
 145    int tmp = 1,num = 0;
!146    int* col_index_A = (int *)calloc(A_row_size*A_col_size,sizeof(int));
 147    int* row_index_A = (int *)calloc(A_row_size*A_col_size,sizeof(int));
 148    Uint* A_tmp = (Uint *)calloc(A_row_size*A_col_size,sizeof(Uint));
 149      for (col=0; col<A_col_size; col++){
 150        for (row=0; row<A_row_size; row++) {
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 3 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=0, A_sparse=0x7ffff7dd1020, B=0x0, C=0x0, B_col_size=10, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Hardware watchpoint 4: *(float*)&C[552*A_col_size]
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Hardware watchpoint 4: *(float*)&C[552*A_col_size]

Old value = <unreadable>
New value = 0
sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:106
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Watchpoint 4 deleted because the program has left the block in
which its expression is valid.
main () at test_chipA_div.c:247
247	  get_nanosec(0);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
 251      sum = 0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 1 at 0x12e9: file test_chipA_div.c, line 107.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 1, main () at test_chipA_div.c:107
107	{ //pointerでないので普通に足される。
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102  
 103  
 104  
 105  
 106  main()
!107  { //pointerでないので普通に足される。
 108    // char* val;
 109    // Uchar* membases = (Uchar*)malloc_test(sizeof(int)*10,&val);
 110    // val = malloc_test(sizeof(int)*10);
 111    // printf("malloc 10 %c \n",val[0]);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Breakpoint 2 at 0x555555555a8e: file test_chipA_div.c, line 246.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, main () at test_chipA_div.c:246
246	  sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 241    show_nanosec();
 242  
 243    reset_nanosec();
 244    // imax();
 245  //   sparse_gemm_768_96_96_768_1(C1, A, B, A_sparse);
!246    sparse_multiply_imax4(nnz_A,A_sparse,B,C1,B_col_size,params);
 247    get_nanosec(0);
 248    show_nanosec();
 249  
 250  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
sparse_multiply_imax4 (nnz=0, A_sparse=0x7ffff7dd1020, B=0x0, C=0x0, B_col_size=10, params=0x0) at util/sparse_multiply.c:97
97	int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  92  
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
98	    if(!A_sparse||!B||!C){
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  93  
  94  
  95  
  96  
  97  int sparse_multiply_imax4(const int nnz,const emax6_sparse2* const A_sparse, const Uint* const B, Uint* C, int B_col_size,emax6_param* params){
  98      if(!A_sparse||!B||!C){
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
104	    int A_nnz =  A_sparse->nnz;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  99          fprintf(stderr,"A,B,C NULL pointer \n");
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
105	    int A_col_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 100          exit(1);
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
106	    int A_row_size = A_sparse->row_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 101      }
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
107	    int* A_col_p = A_sparse->col_p;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 102      
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
108	    Uint* A_nnz_col_index = A_sparse->col_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 103  
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
109	    Uint* A_val_index_set = A_sparse->val_index_set;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 104      int A_nnz =  A_sparse->nnz;
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
110	    Uint* A_sort_index= A_sparse->sort_index;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 105      int A_col_size = A_sparse->col_normal_size;
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
111	    int* A_col_num= A_sparse->col_num;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 106      int A_row_size = A_sparse->row_normal_size;
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
112	    int* A_paddings = A_sparse->paddings;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 107      int* A_col_p = A_sparse->col_p;
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
113	    Ull* A_margin = A_sparse->margin;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 108      Uint* A_nnz_col_index = A_sparse->col_index;
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
114	    Ull* A_margin_sum = A_sparse->margin_sum;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 109      Uint* A_val_index_set = A_sparse->val_index_set;
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
115	    int B_row_size = A_sparse->col_normal_size;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 110      Uint* A_sort_index= A_sparse->sort_index;
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
116	    int A_judge=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 111      int* A_col_num= A_sparse->col_num;
 112      int* A_paddings = A_sparse->paddings;
 113      Ull* A_margin = A_sparse->margin;
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
 120      int RMGRP = params->RMGRP_param;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
119	    int NCHIP = params->NCHIP_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 114      Ull* A_margin_sum = A_sparse->margin_sum;
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
 120      int RMGRP = params->RMGRP_param;
 121      int W = params->W_param; 
 122      int H = params->H_param; 
 123      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
120	    int RMGRP = params->RMGRP_param;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 115      int B_row_size = A_sparse->col_normal_size;
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
 120      int RMGRP = params->RMGRP_param;
 121      int W = params->W_param; 
 122      int H = params->H_param; 
 123      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 124      int pad_index;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
121	    int W = params->W_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 116      int A_judge=0;
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
 120      int RMGRP = params->RMGRP_param;
 121      int W = params->W_param; 
 122      int H = params->H_param; 
 123      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 124      int pad_index;
 125      int count=0;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
122	    int H = params->H_param; 
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 117      int B_row_min,B_row_max;
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
 120      int RMGRP = params->RMGRP_param;
 121      int W = params->W_param; 
 122      int H = params->H_param; 
 123      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 124      int pad_index;
 125      int count=0;
 126      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
123	    int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 118      int A_col_min,A_col_max;
 119      int NCHIP = params->NCHIP_param; 
 120      int RMGRP = params->RMGRP_param;
 121      int W = params->W_param; 
 122      int H = params->H_param; 
 123      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 124      int pad_index;
 125      int count=0;
 126      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 127  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
125	    int count=0;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 120      int RMGRP = params->RMGRP_param;
 121      int W = params->W_param; 
 122      int H = params->H_param; 
 123      int A_col_H_div = A_col_size/H; // Aの列をHで何分割するか
 124      int pad_index;
 125      int count=0;
 126      // memset(C, 0, sizeof(Uint)*A_row_size*B_col_size);
 127  
 128   int top,blk,h,w,blk_iter;
 129    
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
133	  for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 128   int top,blk,h,w,blk_iter;
 129    
 130    Ull CHIP;
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    
 130    Ull CHIP;
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull CHIP;
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
136	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
137	    /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
 141                  // AもBもCも縦方向に格納している。
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
138	            for (h=0; h<H; h+=2) { // 一回で2段を表している
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
 141                  // AもBもCも縦方向に格納している。
 142                  // A  32bit val : 32bit next unit Brow
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
 141                  // AもBもCも縦方向に格納している。
 142                  // A  32bit val : 32bit next unit Brow
 143                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
140	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
 141                  // AもBもCも縦方向に格納している。
 142                  // A  32bit val : 32bit next unit Brow
 143                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 144                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
159	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 154                  //A_indexが一度に2箇所読み出す
 155                  //rofs*2はAindexがBのsimdと同じように格納されているから
 156                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 157                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 158                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 159                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 162                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 163  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
160	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 155                  //rofs*2はAindexがBのsimdと同じように格納されているから
 156                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 157                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 158                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 159                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 162                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 163  
 164                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
161	                  *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 156                  //(h+1)があるのは実際のIMAXがUll単位でindex読み出すのに合わせるため つぎのunitの計算を表している
 157                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 158                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 159                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 162                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 163  
 164                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 165                }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
162	                  *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 157                  // IMAXの実際のコードに対応するために*4しているので、こちらでは/4する
 158                  //+(CHIP*B_col_size/NCHIP+top+cofs+w)*B_row_sizeでsimdのために2をかけないのはw+=2ですでに実現しているから
 159                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 160                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[h*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 161                    *(float*)&C[rofs*B_col_size+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]    += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+(top+cofs+w)*B_row_size];
 162                    *(float*)&C[rofs*B_col_size+1+(top+cofs+w)+CHIP*(A_row_size/NCHIP)*B_col_size]  += *(float*)&A_val_index_set[(h+1)*A_margin[CHIP]+rofs_blk*(A_row_size/NCHIP)+rofs+A_margin_sum[CHIP]*H]**(float*)&B[A_val_index_set[h*A_margin[CHIP]+2*rofs_blk*(A_row_size/NCHIP)+2*rofs+A_margin_sum[CHIP]*H+1+A_row_size*A_col_size]/4+1+(top+cofs+w)*B_row_size];
 163  
 164                  /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
 165                }
 166              }
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
139	                for (w=0; w<W; w+=2) {    // Bcol +=2
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
 141                  // AもBもCも縦方向に格納している。
 142                  // A  32bit val : 32bit next unit Brow
 143                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
140	                count++;
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
 136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
 141                  // AもBもCも縦方向に格納している。
 142                  // A  32bit val : 32bit next unit Brow
 143                  // B simd  2colごとにひとまとめにして1rowにまとめてる  ex [0 480 1 481 2 482 3 483] simdのために次のcolをセットにしている
 144                  // C simdかどうかを選べるようにする　今は普通に格納　future work  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$1 = 0
$2 = 406272
$3 = 406272
Breakpoint 3 at 0x555555572a79: file util/sparse_multiply.c, line 136.
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:136
136	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
!136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$4 = 1
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:136
136	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
!136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$5 = 2
Continuing.
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 3, sparse_multiply_imax4 (nnz=541696, A_sparse=0x5555556286d0, B=0x7ffff779e020, C=0x7ffff7bc0020, B_col_size=736, params=0x5555556286b0) at util/sparse_multiply.c:136
136	  /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
!136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
 140                  count++;
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
$6 = 3
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
135	/*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 130    Ull CHIP;
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
!136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
 139                  for (w=0; w<W; w+=2) {    // Bcol +=2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
[H[J[3J─── Output/messages ────────────────────────────────────────────────────────────────────────────────────────────────────────
134	    for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
─── Source ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 129    
 130    Ull CHIP;
 131    Ull rofs,rofs_blk,cofs;
 132    // AもBも縦方向に格納している
 133    for (top=0; top<B_col_size; top+=RMGRP) { //RMGRPごとに計算するBの列を動かす
 134      for (rofs=0; rofs<A_row_size/NCHIP; rofs+=1) { //blk_iterをmarginに入れたら次のHに飛ばしてくれる
 135  /*3*/ for (CHIP=0; (CHIP<NCHIP); CHIP++) { //marginが0の時は計算省略できる　marginはAの入れ替え時にみる
!136    /*2*/ for (rofs_blk=0; rofs_blk<A_margin[CHIP+1]/(A_row_size/NCHIP); rofs_blk++) { // Aのrow blkの飛び
 137      /*1*/ for (cofs=0; cofs<RMGRP; cofs+=W) { // どれだけBをcolにすすめるか
 138              for (h=0; h<H; h+=2) { // 一回で2段を表している
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
