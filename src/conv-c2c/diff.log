Binary files /home/nakashim/proj-arm64/src/conv-c2c/conv-c2c and ./conv-c2c differ
diff -r /home/nakashim/proj-arm64/src/conv-c2c/conv-c2c.h ./conv-c2c.h
9a10,13
> // #include </usr/include/x86_64-linux-gnu/sys/types.h>
> // #include </usr/include/x86_64-linux-gnu/sys/param.h>
> // #include </usr/include/x86_64-linux-gnu/sys/times.h>
> // #include </usr/include/x86_64-linux-gnu/sys/stat.h>
diff -r /home/nakashim/proj-arm64/src/conv-c2c/conv-c2c.l ./conv-c2c.l
16a17
> #include "yacc_lex_util.h"
22a24
> 
42d43
< mex                  { return(CGRA_MEX); }
205a207,208
> 
> %%
\ No newline at end of file
diff -r /home/nakashim/proj-arm64/src/conv-c2c/conv-c2c.y ./conv-c2c.y
8a9,25
> %{
> 
> #include "yacc_lex_util.h"
> #include "lex.yy.c"
> void yyerror(char *s)
> {
>   if (++y_errornum == 1)
>     fprintf(stderr, "\n");
> #if 0
>   fprintf(stderr, "line %d: \"%s\": %s.\n", y_lineno, yytext, s);
> #endif
>   /* lex -l により,yylinenoが使える */
>   fprintf(stderr, "err%d: line %d: \"%s\": %s.\n", y_errornum, yylineno, yytext, s);
> }
> 
> %}
> 
15,18c32,34
< %token  CGRA_ULL     CGRA_UINT    CGRA_SLL   CGRA_SRL
< %token  CGRA_WHILE   CGRA_FOR
< %token  CGRA_CEX     CGRA_EX4     CGRA_EXE
< %token  CGRA_MEX     CGRA_MO4     CGRA_MOP
---
> %token  CGRA_ULL     CGRA_UINT     CGRA_SLL   CGRA_SRL
> %token  CGRA_WHILE   CGRA_FOR      CGRA_CEX
> %token	CGRA_EX4     CGRA_EXE      CGRA_MO4   CGRA_MO2	CGRA_MOP
41a58
> 		printf("reading line %d\n",y_lineno);
99c116
< EMAX6AUNIT : CGRA_WHILE "(" VARIABLE CGRA_DECR ")" "\{" {
---
> EMAX6AUNIT : CGRA_WHILE '(' VARIABLE CGRA_DECR ')' '{' {
123c140
<         | CGRA_FOR "(" CHIP "=" expr ";" CHIP "<" expr ";" CHIP CGRA_INCR ")" "\{" {
---
>         | CGRA_FOR '(' CHIP '=' expr ';' CHIP '<' expr ';' CHIP CGRA_INCR ')' '{' {
135c152
<         | CGRA_FOR "(" INITNO "=" expr "," LOOPNO "=" ASIS "," XVARIABLE "=" ASIS ";" LOOPNO CGRA_DECR ";" INITNO "=" expr ")" "\{" {
---
>         | CGRA_FOR '(' INITNO '=' expr ',' LOOPNO '=' ASIS ',' XVARIABLE '=' ASIS ';' LOOPNO CGRA_DECR ';' INITNO '=' expr ')' '{' {
146c163
< 	    fprintf(stderr, "in %s: for() INIT#/LOOP# mismatch\n", id[current_prefix].name);
---
> 	    fprintf(stderr, "in %s: for() includes INIT#/LOOP# mismatch\n", id[current_prefix].name);
195c212
<         | CGRA_CEX "(" expr "," cex_dst "," cex_src "," cex_src "," cex_src "," cex_src "," expr ")" ";" {
---
>         | CGRA_CEX '(' expr ',' cex_dst ',' cex_src ',' cex_src ',' cex_src ',' cex_src ',' expr ')' ';' {
217c234
<         | CGRA_EX4 "(" expr "," ex4_dstd "," ex4_src "," expr "," ex4_src "," expr "," ex4_src "," expr "," expr "," ex4_src "," expr "," ex4_src ")" ";" {
---
>         | CGRA_EX4 '(' expr ',' ex4_dstd ',' ex4_src ',' expr ',' ex4_src ',' expr ',' ex4_src ',' expr ',' expr ',' ex4_src ',' expr ',' ex4_src ')' ';' {
255c272
<         | CGRA_EX4 "(" expr "," exe_dstd "," exe_src1 "," expr "," ex4_src "," expr "," ex4_src "," expr "," expr "," ex4_src "," expr "," exe_src5 ")" ";" {
---
>         | CGRA_EX4 '(' expr ',' exe_dstd ',' exe_src1 ',' expr ',' ex4_src ',' expr ',' ex4_src ',' expr ',' expr ',' ex4_src ',' expr ',' exe_src5 ')' ';' {
289c306
<         | CGRA_EX4 "(" expr "," exe_dstd "," INITNO "?" exe_src1 ":" exe_src1 "," expr "," ex4_src "," expr "," ex4_src "," expr "," expr "," ex4_src "," expr "," exe_src5 ")" ";" {
---
>         | CGRA_EX4 '(' expr ',' exe_dstd ',' INITNO '?' exe_src1 ':' exe_src1 ',' expr ',' ex4_src ',' expr ',' ex4_src ',' expr ',' expr ',' ex4_src ',' expr ',' exe_src5 ')' ';' {
332c349
<         | CGRA_EXE "(" expr "," exe_dstd "," exe_src1 "," expr "," exe_src2 "," expr "," exe_src3 "," expr "," expr "," exe_src4 "," expr "," exe_src5 ")" ";" {
---
>         | CGRA_EXE '(' expr ',' exe_dstd ',' exe_src1 ',' expr ',' exe_src2 ',' expr ',' exe_src3 ',' expr ',' expr ',' exe_src4 ',' expr ',' exe_src5 ')' ';' {
364c381
<         | CGRA_EXE "(" expr "," exe_dstd "," INITNO "?" exe_src1 ":" exe_src1 "," expr "," exe_src2 "," expr "," exe_src3 "," expr "," expr "," exe_src4 "," expr "," exe_src5 ")" ";" {
---
>         | CGRA_EXE '(' expr ',' exe_dstd ',' INITNO '?' exe_src1 ':' exe_src1 ',' expr ',' exe_src2 ',' expr ',' exe_src3 ',' expr ',' expr ',' exe_src4 ',' expr ',' exe_src5 ')' ';' {
405c422
<         | CGRA_EXE "(" expr "," exe_dstd "," exe_src1 "," expr "," INITNO "?" exe_src2 ":" expr "," expr "," exe_src3 "," expr "," expr "," exe_src4 "," expr "," exe_src5 ")" ";" {
---
>         | CGRA_EXE '(' expr ',' exe_dstd ',' exe_src1 ',' expr ',' INITNO '?' exe_src2 ':' expr ',' expr ',' exe_src3 ',' expr ',' expr ',' exe_src4 ',' expr ',' exe_src5 ')' ';' {
446,501c463
<         | CGRA_MEX "(" expr "," mex_dst "," INITNO "?" XVARIABLE ":" XVARIABLE "," INITNO "?" expr ":" expr "," mex_src3 "," mex_src4 ")" ";" {
< 	  /* mex(OP_CMPA_LE, &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
< 	  /* mex(OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
< 	  /* mop(OP_LDR, 3,  &BR[r][2][1], b0[h],       bofs, MSK_W1, b,          2*LP*RMGRP,  0, 0, NULL, 2*LP*RMGRP); */
< 	  /* mop(OP_LDR, 3,  &BR[r][2][0], a0[h][CHIP], cofs, MSK_W1, a[h][CHIP], 2*LP,        0, 0, NULL, 2*LP); */
< 	  int loop_no0 = id[$7].val;
<           if (last_insn >= INSN_DEPTH) {
< 	    fprintf(stderr, "in %s: last_insn exceeds INSN_DEPTH=%d\n", id[current_prefix].name, INSN_DEPTH);
<             exit(1);
<           }
< 	  if (loop_no0 != 0) {
< 	    fprintf(stderr, "in %s: mex(INIT0) should be specified\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if ($5 != $11) {
< 	    fprintf(stderr, "in %s: exe(dst,INIT0?src1:src2) dst and src2 should be the same\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if (loop_no0 != id[$13].val) {
< 	    fprintf(stderr, "in %s: mex() INIT# mismatch\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if (id[$15].val != 0) {
< 	    fprintf(stderr, "in %s: mex(INIT0?expr1:expr2) expr1 should be zero\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if (id[$19].val != id[$21].val) {
< 	    fprintf(stderr, "in %s: mex(src3[%d][%d],src4[%d][%d]) should be the same row/col\n", id[current_prefix].name, (Uint)id[$19].val/EMAX_WIDTH, (Uint)id[$19].val%EMAX_WIDTH, (Uint)id[$21].val/EMAX_WIDTH, (Uint)id[$21].val%EMAX_WIDTH);
<             exit(1);
< 	  }
< 	  if (insn[last_insn].imex.src3s != 1 || insn[last_insn].imex.src4s != 0) {
< 	    fprintf(stderr, "in %s: mex(src3[%d][%d][%d],src4[%d][%d][%d]) should be src3[][][1] and src4[][][0]\n", id[current_prefix].name, (Uint)id[$19].val/EMAX_WIDTH, (Uint)id[$19].val%EMAX_WIDTH, insn[last_insn].imex.src3s, (Uint)id[$21].val/EMAX_WIDTH, (Uint)id[$21].val%EMAX_WIDTH, insn[last_insn].imex.src4s);
<             exit(1);
< 	  }
< 	  insn[last_insn].iheader.type = 6; /* MEX */
< 	  insn[last_insn].iheader.row  = id[$19].type==T_BDRNO?(id[$19].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$19].type==T_BDRNO?(id[$19].val%EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].imex.op      = id[ $3].val; /* activate self_update */
< 	  insn[last_insn].imex.init    = 1;           /* activate INIT0?src1 */
< 	  insn[last_insn].imex.src1v   = id[ $9].type;
< 	  insn[last_insn].imex.src1h   = $9;
< 	  insn[last_insn].imex.src1s   = -1;
< 	  insn[last_insn].imex.src2v   = id[$11].type;
< 	  insn[last_insn].imex.src2h   = $15;
< 	  insn[last_insn].imex.src2s   = -1;
< 	  insn[last_insn].imex.distv   = id[$17].type;
< 	  insn[last_insn].imex.disth   = $17;
< 	  insn[last_insn].imex.src3v   = id[$19].type;
< 	  insn[last_insn].imex.src3h   = $19;
< 	  insn[last_insn].imex.src4v   = id[$21].type;
< 	  insn[last_insn].imex.src4h   = $25;
< 	  insn[last_insn].imex.mexdv   = id[ $5].type;
< 	  insn[last_insn].imex.mexdh   = $5;
<           last_insn++;
<         }
<         | CGRA_MO4 "(" expr "," mop_ex "," mo4_srcdst "," mop_base "," mop_offset "," expr "," mop_top "," mop_len "," expr "," force "," mop_top "," mop_len ")" ";" {
---
>         | CGRA_MO4 '(' expr ',' mop_ex ',' mo4_srcdst ',' mop_base ',' mop_offset ',' expr ',' mop_top ',' mop_len ',' expr ',' force ',' mop_top ',' mop_len ')' ';' {
508,510c470,472
< 	  insn[last_insn].iheader.type = 7; /* MO4 */
< 	  insn[last_insn].iheader.row  = id[ $7].type==T_ALRNO?(id[$7].val):id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $7].type==T_ALRNO?(        -1):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.type = 6; /* MO4 */
> 	  insn[last_insn].iheader.row  = id[$7].type==T_ALRNO?(id[$7].val):id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$7].type==T_ALRNO?(        -1):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
538,540c500,501
< 	      insn[last_insn].imex.op      = OP_ALWAYS;
< 	      insn[last_insn].imex.distv   = T_IMMEDIATE;
< 	      insn[last_insn].imex.disth   = hash_reg_immediate(size);
---
> 	      insn[last_insn].imop.offsv   = T_IMMEDIATE;
> 	      insn[last_insn].imop.offsh   = hash_reg_immediate(size);
553,555c514,516
< 	    insn[last_insn].imex.op      = OP_ALWAYS;
< 	    insn[last_insn].imex.distv   = T_IMMEDIATE;
< 	    insn[last_insn].imex.disth   = hash_reg_immediate(32LL);
---
> 	    insn[last_insn].imop.offsv   = T_IMMEDIATE;
> 	    insn[last_insn].imop.offsh   = hash_reg_immediate(32LL);
> 	    insn[last_insn].imop.offss   = -1;
571c532
<         | CGRA_MOP "(" expr "," mop_ex "," mop_srcdst "," mop_base "," mop_offset "," expr "," mop_top "," mop_len "," expr "," force "," mop_top "," mop_len ")" ";" {
---
>         | CGRA_MOP '(' expr ',' mop_ex ',' mop_srcdst ',' mop_base ',' mop_offset ',' expr ',' mop_top ',' mop_len ',' expr ',' force ',' mop_top ',' mop_len ')' ';' {
578,580c539,541
< 	  insn[last_insn].iheader.type = 8; /* MOP */
< 	  insn[last_insn].iheader.row  = id[ $7].type==T_ALRNO?(id[$7].val)                :id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $7].type==T_ALRNO?(insn[last_insn].imop.mopds):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.type = 7; /* MOP */
> 	  insn[last_insn].iheader.row  = id[$7].type==T_ALRNO?(id[$7].val)                :id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$7].type==T_ALRNO?(insn[last_insn].imop.mopds):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
612,614c573,574
< 	      insn[last_insn].imex.op      = OP_ALWAYS;
< 	      insn[last_insn].imex.distv   = T_IMMEDIATE;
< 	      insn[last_insn].imex.disth   = hash_reg_immediate(size);
---
> 	      insn[last_insn].imop.offsv   = T_IMMEDIATE;
> 	      insn[last_insn].imop.offsh   = hash_reg_immediate(size);
631c591
<         | "\}" {
---
>         | '}' {
648c608
< cex_dst : "\&" EXRNO {
---
> cex_dst : '&' EXRNO {
690c650
<         | ALRNO "\[" expr "\]" { /* AR[r][s] */
---
>         | ALRNO '[' expr ']' { /* AR[r][s] */
694c654
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
---
>         | BDRNO '[' expr ']' { /* BR[r][c][s] */
712c672
<         | ALRNO "\[" expr "\]" { /* AR[r][s] */
---
>         | ALRNO '[' expr ']' { /* AR[r][s] */
716c676
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
---
>         | BDRNO '[' expr ']' { /* BR[r][c][s] */
734c694
<         | ALRNO "\[" expr "\]" { /* AR[r][s] */
---
>         | ALRNO '[' expr ']' { /* AR[r][s] */
738c698
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
---
>         | BDRNO '[' expr ']' { /* BR[r][c][s] */
756c716
<         | ALRNO "\[" expr "\]" { /* AR[r][s] */
---
>         | ALRNO '[' expr ']' { /* AR[r][s] */
760c720
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
---
>         | BDRNO '[' expr ']' { /* BR[r][c][s] */
778c738
<         | ALRNO "\[" expr "\]" { /* AR[r][s] */
---
>         | ALRNO '[' expr ']' { /* AR[r][s] */
782c742
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
---
>         | BDRNO '[' expr ']' { /* BR[r][c][s] */
788c748
< exe_dstd : "\&" XVARIABLE { /* &var */
---
> exe_dstd : '&' XVARIABLE { /* &var */
792c752
<         | "\&" ALRNO "\[" expr "\]" { /* &AR[r][s] */
---
>         | '&' ALRNO '[' expr ']' { /* &AR[r][s] */
798,835d757
< mex_src1 : XVARIABLE {
< 	  insn[last_insn].imex.src1s = -1;
<           $$ = $1;
<         }
<         ;
< 
< mex_src2 : XVARIABLE {
< 	  insn[last_insn].imex.src2s = -1;
<           $$ = $1;
<         }
<         ;
< 
< mex_src3 : expr {
< 	  insn[last_insn].iexe.src3s = -1;
<           $$ = $1;
<         }
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
< 	  insn[last_insn].imex.src3s = id[$3].val;
<           $$ = $1;
<         }
<         ;
< 
< mex_src4 : expr {
< 	  insn[last_insn].iexe.src4s = -1;
<           $$ = $1;
<         }
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
< 	  insn[last_insn].imex.src4s = id[$3].val;
<           $$ = $1;
<         }
<         ;
< 
< mex_dst : "\&" XVARIABLE {
< 	  insn[last_insn].imex.mexds = -1;
<           $$ = $2;
< 	}
< 	;
< 
855c777
< mop_srcdst : "\&" XVARIABLE { /* for load/store */
---
> mop_srcdst : '&' XVARIABLE { /* for load/store */
859c781
<         | "\&" ALRNO "\[" expr "\]" { /* for store */
---
>         | '&' ALRNO '[' expr ']' { /* for store */
863c785
<         | "\&" BDRNO "\[" expr "\]" { /* for load */
---
>         | '&' BDRNO '[' expr ']' { /* for load */
882c804
< 	  insn[last_insn].imop.updt  = 1;
---
> 	  insn[last_insn].imop.updt = 1;
886,887c808,809
<         | CGRA_ULL "(" XVARIABLE CGRA_INCR ")" {
< 	  insn[last_insn].imop.updt  = 1;
---
>         | CGRA_ULL '(' XVARIABLE CGRA_INCR ')' {
> 	  insn[last_insn].imop.updt = 1;
891c813
<         | BDRNO "\[" expr "\]" {
---
>         | BDRNO '[' expr ']' {
909c831
<         | BDRNO "\[" expr "\]" {
---
>         | BDRNO '[' expr ']' {
952c874
<         | VARIABLE "[" CHIP "]" {
---
>         | VARIABLE '[' CHIP ']' {
963c885
<         | expr "\+" term {
---
>         | expr '+' term {
976c898
<         | expr "\-" term {
---
>         | expr '-' term {
1015c937
<         | expr "\&" term {
---
>         | expr '&' term {
1028c950
<         | expr "\^" term {
---
>         | expr '^' term {
1041c963
<         | expr "\|" term {
---
>         | expr '|' term {
1059c981
<         | "\~" factor {
---
>         | '~' factor {
1070c992
<         | "-" factor {
---
>         | '-' factor {
1081c1003
<         | term "\*" factor {
---
>         | term '*' factor {
1094c1016
<         | term "\/" factor {
---
>         | term '/' factor {
1109c1031
< factor : "(" expr ")" {
---
> factor : '(' expr ')' {
1138,1140d1059
< #include "conv-c2c.h"
< #include "emax6.h"
< #include "lex.yy.c"
1142,1219d1060
< hash(s) register char *s;
< {
<   register int    hashval;
< 
<   for (hashval=0; *s!=0;)
<     hashval += *s++;
<   return(hashval % ID_NUM+1);
< }
< 
< hash_clear()
< {
<   register int    i;
< 
<   for (i=0; i<ID_NUM; i++) {
<     id[i].name  = NULL;
<     id[i].type  = 0;
<     id[i].itype = 0;
<     id[i].row   = 0;
<     id[i].col   = 0;
<   }
< }
< 
< hash_search(buf, reth) char *buf; int *reth;
< {
<   /* return 0 ... new id[reth] is assigned */
<   /* return 1 ... old id[reth] is found */
<   char *bufptr;
<   int  hashval, hashsave, buflen;
< 
<   /* hash */
<   hashval = hashsave = hash(buf);
<   while (id[hashval].name != NULL) {
<     if (!strncmp(buf, id[hashval].name, BUF_MAXLEN)) {
<       *reth = hashval;
<       return (1);
<     }
<     hashval = rehash(hashval);
<     if (hashval == hashsave)
<       break;
<   }
<   if (id[hashval].name != NULL) {
<     yyerror("too many IDs");
<     fprintf(stderr, "current ID_NUM is %d\n", ID_NUM);
<     exit(1);
<   }
< 
<   /* new number */
<   buflen = strlen(buf)+1;
<   id[hashval].name = bufptr = malloc(buflen);
<   id[hashval].row = -1; /* init */
<   id[hashval].col = -1; /* init */
<   strncpy(bufptr, buf, buflen);
<   *reth = hashval;
<   return(0);
< }
< 
< hash_reg_immediate(imm) Ull imm;
< {
<   int hashval;
<   /* return hashval */
<   snprintf(buf, BUF_MAXLEN, "%lldLL", imm);
<   if (!hash_search(buf, &hashval)) { /* not found */
<     id[hashval].type = T_IMMEDIATE;
<     id[hashval].val = imm;
<   }
<   return (hashval);
< }
< 
< yyerror(s) char *s;
< {
<   if (++y_errornum == 1)
<     fprintf(stderr, "\n");
< #if 0
<   fprintf(stderr, "line %d: \"%s\": %s.\n", y_lineno, yytext, s);
< #endif
<   /* lex -l により,yylinenoが使える */
<   fprintf(stderr, "err%d: line %d: \"%s\": %s.\n", y_errornum, yylineno, yytext, s);
< }
Only in ./: diff.log
diff -r /home/nakashim/proj-arm64/src/conv-c2c/emax6.c ./emax6.c
2c2
< static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.89 2021/09/21 07:42:15 nakashim Exp nakashim $";
---
> static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.87 2021/08/11 04:45:48 nakashim Exp nakashim $";
15c15
< emit_emax6a(int mode) /* 0:array, 1:drain */
---
> int emit_emax6a(int mode) /* 0:array, 1:drain */
20d19
<   int last_mex = -1; /* 0:mex0, 1:mex1 */
25d23
<   struct mex *dmex0, *dmex1;
604d601
<       case OP_CFMA:   /* 3 */
822,915d818
<     case ITYPE_MEX: /* MEX */
<       /* mex(OP_CMPA_LE, &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
<       /* mex(OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
<       /* mop(OP_LDR, 3,  &BR[r][2][1], b0[h],       bofs, MSK_W1, b,          2*LP*RMGRP,  0, 0, NULL, 2*LP*RMGRP); */
<       /* mop(OP_LDR, 3,  &BR[r][2][0], a0[h][CHIP], cofs, MSK_W1, a[h][CHIP], 2*LP,        0, 0, NULL, 2*LP); */
<       switch (insn[i].imex.op) {
<       case OP_CMPA_LE:
<       case OP_CMPA_GE:
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src3v, insn[i].imex.src3h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src4v, insn[i].imex.src4h, rdep);
<         break;
<       case OP_ALWAYS:
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
<         break;
<       }
< 
<       folding = 1; /* set */
< 
<       if (row < 0) { /* OP_ALWAYSの場合,BR[][]指定無し */
<         /* 1-2a */
< 	if (last_row < *rdep) { /* 間を空けて配置可能 */
< 	  last_row = *rdep;
< 	  last_col = 0;
< 	}
< 	else { /* last_row >= *rdep *//* 最終位置と依存関係制約位置が一致 */
< 	  last_col++; /* overflowはあとで検査.EXEがWIDTH以上あれば次段へ移動 */
< 	  if (last_col >= EMAX_WIDTH) {
< 	    last_row++;
< 	    last_col = 0;
< 	  }
< 	}
<       }
<       else { /* WHILE/ALR/BDR is specified */
<         /* 1-2b */
<         if (row < *rdep) {
< 	  printf("in %s: mex cannot locate destination BDRNO (row=%d)\n", id[current_prefix].name, row);
< 	  exit(1);
< 	}
< 	else if (row < last_row) {
<           printf("in %s: mex found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
<           exit(1);
<         }
<         else {
<           last_row = row;
<           last_col = col;
<         }
<       }
<       /* 1-3 */
<       //printf("ITYPE_MEX: row=%d col=%d rdep=%d last_row=%d last_col=%d\n", row, col, *rdep, last_row, last_col);
<       if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
<         printf("in %s: [%d][%d] mex exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
<         exit(1);
<       }
<       if      (!dec[last_row][last_col].dmex1.op)
< 	last_mex = 1;
<       else if (!dec[last_row][last_col].dmex0.op)
< 	last_mex = 0;
<       else {
<         printf("in %s: [%d][%d] mex conflicts\n", id[current_prefix].name, last_row, last_col);
<         exit(1);
<       }
<       /* 1-4 */
<       dmex0 = &dec[last_row][last_col].dmex0;
<       dmex1 = &dec[last_row][last_col].dmex1;
<       if (last_mex==1) /* load */
<         *dmex1 = insn[i].imex;
<       else /* store/load */
<         *dmex0 = insn[i].imex;
<       /* 1-5 */
<       /* BR[][][1],BR[][][0]からの戻りは常時接続なのでselector追加不要 */
<       /* ea14woofs,ea04woofsからの戻りは常時接続なのでselector追加不要 */
<       if (last_mex==1) { /* first */
<         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmex1->src1v, dmex1->src1h, dmex1->src1s);
<       }
<       else { /* second */
<         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmex0->src1v, dmex0->src1h, dmex0->src1s);
<       }
<       /* 1-6 */
<       /* BR[][][1],BR[][][0]からの戻りは常時接続なのでbus設定不要 */
<       /* ea14woofs,ea04woofsからの戻りは常時接続なのでbus設定不要 */
<       if (last_mex==1) { /* first */
< 	/* do nothing */
<       }
<       else { /* second */
< 	/* do nothing */
<       }
<       id[insn[i].imex.mexdh].itype = ITYPE_MEX;
<       id[insn[i].imex.mexdh].row   = last_row;
<       id[insn[i].imex.mexdh].col   = last_col;
<       insn[i].iheader.fixed = 1;
<       break;
1024,1025c927,928
<         dmop1->updt  = 1;            /* for internal update of ea1 */
<         dmop1->offsm = 14;           /* for internal update of ea1 */
---
>         dmop1->updt  = 1;  /* for internal update of ea1 */
>         dmop1->offsm = 15; /* for internal update of ea1 */
1029,1030c932,933
<         dmop1->updt  = 1;            /* for internal update of ea1 */
<         dmop1->offsm = 14;           /* for internal update of ea1 */
---
>         dmop1->updt  = 1;  /* for internal update of ea1 */
>         dmop1->offsm = 15; /* for internal update of ea1 */
1041c944
< 	set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
---
>         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
1486,1492d1388
<           int mex2_and_op0_is_empty = (op1 && !op0) && (typ == MTYPE_RLOAD)
<                                    && (typ == insn[i].imop.mtype)
<                                    && (blk == insn[i].imop.blk)
<                                    && (fcev== insn[i].imop.forcev)
<                                    && (fceh== insn[i].imop.forceh)
< 	                           && (dec[last_row][last_col].dmex0.op)
< 	                           && (dec[last_row][last_col].dmex1.op);
1495,1496d1390
< 	  else if (mex2_and_op0_is_empty) /* mex should merge op1(map to LMM/col2) and op0(map to LMM/col1) w/ different top */
< 	    last_mop = 0; /* mex load */
1519,1520d1412
<       dmex0 = &dec[last_row][last_col].dmex0;
<       dmex1 = &dec[last_row][last_col].dmex1;
1523c1415
<       if (last_mop==1) { /* load */
---
>       if (last_mop==1) /* load */
1525,1532c1417
< 	if (dmex1->op && insn[i].imex.op) {
< 	  printf("in %s: [%d][%d] mex1 & mop1(adr++) conflicts\n", id[current_prefix].name, last_row, last_col);
< 	  exit(1);
< 	}
< 	else if (insn[i].imex.op)
< 	  *dmex1 = insn[i].imex;
<       }
<       else { /* store/load */
---
>       else /* store/load */
1534,1540d1418
< 	if (dmex0->op && insn[i].imex.op) {
< 	  printf("in %s: [%d][%d] mex0 & mop0(adr++) conflicts\n", id[current_prefix].name, last_row, last_col);
< 	  exit(1);
< 	}
< 	else if (insn[i].imex.op)
< 	  *dmex0 = insn[i].imex;
<       }
1550,1551c1428
< 	if (!(dmex1->op && dmex1->mexdh == dmop1->baseh))
< 	  set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
---
>         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
1557,1559d1433
<           if (dmop1->mtype == MTYPE_RLOAD && dmex1->op == OP_CMPA_LE || dmex1->op == OP_CMPA_GE) {
< 	    //printf("MOP1 CMPA RLOAD\n");
< 	  }
1634,1635c1508
< 	if (!(dmex0->op && dmex0->mexdh == dmop0->baseh))
< 	  set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
---
>         set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
1638,1641c1511
< 	  int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
< 	  int f  = id[dmop0->forceh].val;
< 	  int p  = 0; /* initial value */
<           if (dmop0->mtype == MTYPE_RLOAD && !(dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE)) {
---
>           if (insn[i].imop.mtype == MTYPE_RLOAD) {
1644,1656c1514,1517
<           else { /* includes dmop0->mtype == MTYPE_RLOAD && (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) */
< 	    int last_col_mex;
< 	    if (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) {
< 	      //printf("MOP0 CMPA RLOAD\n");
< 	      if (last_col < 2) {
< 		printf("in %s: [%d][%d] mex0 should be located col>=2\n", id[current_prefix].name, last_row, last_col);
< 		exit(1);
< 	      }
< 	      last_col_mex = last_col-1;
< 	      printf("dmex0.lmm moved from col%d to col%d ", last_col, last_col_mex);
< 	    }
< 	    else /* normal mop w/o mex */
< 	      last_col_mex = last_col;
---
>           else {
> 	    int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
> 	    int f  = id[dmop0->forceh].val;
> 	    int p  = 0; /* initial value */
1658,1676c1519,1537
< 	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
< 	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
< 	    case 6: /* lmx */                                     conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
< 	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
< 	    }
< 	    conf[last_row][last_col_mex].cdw2.lmm_mode = 3;
<             lmmi[last_row][last_col_mex].v     = 1;
<             lmmi[last_row][last_col_mex].rw    = rw;
<             lmmi[last_row][last_col_mex].f     = f;
<             lmmi[last_row][last_col_mex].p     = p;
<             lmmi[last_row][last_col_mex].blk   = dmop0->blk;
< 	    lmmi[last_row][last_col_mex].cidx  = id[dmop0->toph].cidx;
<             lmmi[last_row][last_col_mex].len   = id[dmop0->lenh].val-1;
<             lmmi[last_row][last_col_mex].ofs   = 0; /* initial value */
<             lmmi[last_row][last_col_mex].top   = (Ull)id[dmop0->toph].name;
<             lmmx[last_row][last_col_mex].forcev= dmop0->forcev;
<             lmmx[last_row][last_col_mex].forceh= dmop0->forceh;
<             lmmx[last_row][last_col_mex].lenv  = dmop0->lenv;
<             lmmx[last_row][last_col_mex].lenh  = dmop0->lenh;
---
> 	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
> 	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
> 	    case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
> 	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
> 	    }
> 	    conf[last_row][last_col].cdw2.lmm_mode = 3;
>             lmmi[last_row][last_col].v     = 1;
>             lmmi[last_row][last_col].rw    = rw;
>             lmmi[last_row][last_col].f     = f;
>             lmmi[last_row][last_col].p     = p;
>             lmmi[last_row][last_col].blk   = dmop0->blk;
> 	    lmmi[last_row][last_col].cidx  = id[dmop0->toph].cidx;
>             lmmi[last_row][last_col].len   = id[dmop0->lenh].val-1;
>             lmmi[last_row][last_col].ofs   = 0; /* initial value */
>             lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
>             lmmx[last_row][last_col].forcev= dmop0->forcev;
>             lmmx[last_row][last_col].forceh= dmop0->forceh;
>             lmmx[last_row][last_col].lenv  = dmop0->lenv;
>             lmmx[last_row][last_col].lenh  = dmop0->lenh;
1840d1700
<       //printf("conf[%d][%d]: init=%d fold=%d\n", i, j, conf[i][j].cdw0.init, conf[i][j].cdw0.fold);
1849,1872d1708
< 
<       /* mex0/mop0 */
<       conf[i][j].cdw0.mex0op   = dec[i][j].dmex0.op;
<       conf[i][j].cdw0.mex0init = dec[i][j].dmex0.init;
<       switch (id[dec[i][j].dmex0.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<       case  0: conf[i][j].cdw0.mex0dist = 0; break;
<       case  1: conf[i][j].cdw0.mex0dist = 1; break;
<       case  2: conf[i][j].cdw0.mex0dist = 2; break;
<       case  4: conf[i][j].cdw0.mex0dist = 3; break;
<       case  8: conf[i][j].cdw0.mex0dist = 4; break;
<       case 16: conf[i][j].cdw0.mex0dist = 5; break;
<       case 32: conf[i][j].cdw0.mex0dist = 6; break;
<       default: conf[i][j].cdw0.mex0dist = 7; break;
<       }
<       /* mex0.mexdh and mop0.mopdh */
<       if (dec[i][j].dmex0.op && dec[i][j].dmex0.mexdh == dec[i][j].dmop0.baseh) {
< 	printf("[%d][%d] detected dmex0.dst==mop0.base.", i, j);
< 	                    dec[i][j].dmop0.updt  = 1;
< 	regv[i][j].ea0b_v = dec[i][j].dmop0.basev = dec[i][j].dmex0.src1v; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea0b_h = dec[i][j].dmop0.baseh = dec[i][j].dmex0.src1h; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea0b_s = dec[i][j].dmop0.bases = dec[i][j].dmex0.src1s; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
< 	printf(" mop0 renamed from %s to %s\n", id[dec[i][j].dmex0.mexdh].name, id[dec[i][j].dmop0.baseh].name);
<       }
< 
1875,1877c1711,1713
<       conf[i][j].cdw1.ea0op    = dec[i][j].dmop0.op;
<       conf[i][j].cdw1.ea0bs    = ((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
<       conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1; /* 0:ea0or, 1:eaobrs */
---
>       conf[i][j].cdw1.ea0op  = dec[i][j].dmop0.op;
>       conf[i][j].cdw1.ea0bs  =((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
>       conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1;                             /* 0:ea0or, 1:eaobrs */
1879,1903d1714
< 
<       /* mex1/mop1 */
<       conf[i][j].cdw0.mex1op   = dec[i][j].dmex1.op;
<       conf[i][j].cdw0.mex1init = dec[i][j].dmex1.init;
<       switch (id[dec[i][j].dmex1.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<       case  0: conf[i][j].cdw0.mex1dist = 0; break;
<       case  1: conf[i][j].cdw0.mex1dist = 1; break;
<       case  2: conf[i][j].cdw0.mex1dist = 2; break;
<       case  4: conf[i][j].cdw0.mex1dist = 3; break;
<       case  8: conf[i][j].cdw0.mex1dist = 4; break;
<       case 16: conf[i][j].cdw0.mex1dist = 5; break;
<       case 32: conf[i][j].cdw0.mex1dist = 6; break;
<       default: conf[i][j].cdw0.mex1dist = 7; break;
<       }
<       /* mex1.mexdh and mop1.mopdh */
<       if (dec[i][j].dmex1.op && dec[i][j].dmex1.mexdh == dec[i][j].dmop1.baseh) {
< 	printf("[%d][%d] detected dmex1.dst==mop1.base.", i, j);
< 	                    dec[i][j].dmop1.updt  = 1;
< 	regv[i][j].ea1b_v = dec[i][j].dmop1.basev = dec[i][j].dmex1.src1v; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea1b_h = dec[i][j].dmop1.baseh = dec[i][j].dmex1.src1h; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea1b_s = dec[i][j].dmop1.bases = dec[i][j].dmex1.src1s; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
< 	printf(" mop1 renamed from %s to %s\n", id[dec[i][j].dmex1.mexdh].name, id[dec[i][j].dmop1.baseh].name);
<       }
< 
<       /* ea[bo] depends on busmap[i][j].br[prev][] and decode[i][j].dmop.ex[123] */
1906c1717
<         conf[i][j].cdw1.ea1op = dec[i][j].dmop0.op;
---
>         conf[i][j].cdw1.ea1op  = dec[i][j].dmop0.op;
1908,1910c1719,1721
<         conf[i][j].cdw1.ea1op = dec[i][j].dmop1.op;
<       conf[i][j].cdw1.ea1bs  = ((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
<       conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1; /* 0:ea1or, 1:eaobrs */
---
>         conf[i][j].cdw1.ea1op  = dec[i][j].dmop1.op;
>       conf[i][j].cdw1.ea1bs  =((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
>       conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1;                             /* 0:ea1or, 1:eaobrs */
1912,1914d1722
< 
<       //printf("conf[%d][%d]: mex0=%d.%d.%d mex1=%d.%d.%d\n", i, j, conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0init, conf[i][j].cdw0.mex0dist, conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1init, conf[i][j].cdw0.mex1dist);
< 
2617a2426
>   fprintf(ofile, "\temax6.lastdist = 0;\n");
2751d2559
<   fprintf(ofile, "\t  emax6.lastdist = 0;\n");
2852c2660
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = %s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
2855c2663
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = (Ull)%s;\n", i, j, id[regv[i][j].ea0b_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s;\n", i, j, id[regv[i][j].ea0b_h].name);
2857c2665
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
2862c2670
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = %s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
2865c2673
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = (Ull)%s;\n", i, j, id[regv[i][j].ea0o_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s;\n", i, j, id[regv[i][j].ea0o_h].name);
2867c2675
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
2872c2680
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = %s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
2875c2683
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = (Ull)%s;\n", i, j, id[regv[i][j].ea1b_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s;\n", i, j, id[regv[i][j].ea1b_h].name);
2877c2685
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
2882c2690
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = %s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
2885c2693
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = (Ull)%s;\n", i, j, id[regv[i][j].ea1o_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s;\n", i, j, id[regv[i][j].ea1o_h].name);
2887c2695
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
3115a2924
> 
3212,3213c3021,3022
<      /* reg_type:  ITYPE_MEX/ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
<      /* reg_loc:   ITYPE_MEX/ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
---
>      /* reg_type:  ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
>      /* reg_loc:   ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
3226c3035
<     if (insn_type == ITYPE_MEX || insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
---
>     if (insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
3229c3038
<         printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>         printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3234c3043
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3247c3056
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3262c3071
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3273c3082
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3704,3713c3513,3518
<            conf[i][j].cdw1.ea0op,   /*:  5; mem_opcd */
<            conf[i][j].cdw1.ea0bs,   /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
<            conf[i][j].cdw1.ea0os,   /*:  1; 0:ea0or, 1:eaobrs */
<            conf[i][j].cdw1.ea0msk,  /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
<            conf[i][j].cdw1.eabbrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
<            conf[i][j].cdw1.eaobrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	   conf[i][j].cdw0.mex0op,  /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
< 	   conf[i][j].cdw0.mex0init,/* mex(sparse matrix) 0:none, 1:INIT0? */
< 	   conf[i][j].cdw0.mex0dist /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
< 
---
>            conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
>            conf[i][j].cdw1.ea0bs,  /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
>            conf[i][j].cdw1.ea0os,  /*:  1; 0:ea0or, 1:eaobrs */
>            conf[i][j].cdw1.ea0msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
>            conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
>            conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
3717,3725c3522,3527
<            conf[i][j].cdw1.ea1op,   /*:  5; mem_opcd */
<            conf[i][j].cdw1.ea1bs,   /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
<            conf[i][j].cdw1.ea1os,   /*:  1; 0:ea1or, 1:eaobrs */
<            conf[i][j].cdw1.ea1msk,  /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
<            conf[i][j].cdw1.eabbrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
<            conf[i][j].cdw1.eaobrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	   conf[i][j].cdw0.mex1op,  /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
< 	   conf[i][j].cdw0.mex1init,/* mex(sparse matrix) 0:none, 1:INIT0? */
< 	   conf[i][j].cdw0.mex1dist /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
---
>            conf[i][j].cdw1.ea1op,  /*:  5; mem_opcd */
>            conf[i][j].cdw1.ea1bs,  /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
>            conf[i][j].cdw1.ea1os,  /*:  1; 0:ea1or, 1:eaobrs */
>            conf[i][j].cdw1.ea1msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
>            conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
>            conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
3744,3752c3546,3552
< 	   lmmi[i][j].v,            /*:  1; valid */
<            conf[i][j].cdw1.ea0op,   /*:  5; mem_opcd */
<            conf[i][j].cdw2.mwsa,    /*:  1; 0:lmwa,  1:ea0d        */
<            conf[i][j].cdw2.mws0,    /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
<            conf[i][j].cdw2.mws1,    /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
<            conf[i][j].cdw2.mws2,    /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
<            conf[i][j].cdw2.mws3,    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
<            conf[i][j].cdw2.lmm_mode,/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
<            lmmi[i][j].top
---
>            conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
>            conf[i][j].cdw2.mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
>            conf[i][j].cdw2.mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
>            conf[i][j].cdw2.mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
>            conf[i][j].cdw2.mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
>            conf[i][j].cdw2.mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
>            conf[i][j].cdw2.lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
3764d3563
<            bus[i][j].br[0].s,
3767d3565
<            bus[i][j].br[1].s,
3770d3567
<            bus[i][j].br[2].s,
3772,3773c3569
<            bus[i][j].br[3].h,
<            bus[i][j].br[3].s
---
>            bus[i][j].br[3].h
4174,4177c3970
<          int eaobrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	 int mex0op,
< 	 int mex0init,
< 	 int mex0dist
---
>          int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
4240,4242c4033
< 
<   /* feedback-loop */
<   if (ea0bs & 1) {
---
>   if (ea0bs & 1) { /* feedback-loop */
4253,4267d4043
< 
<   /* mex-loop */
<   if (mex0op==OP_CMPA_LE || mex0op==OP_CMPA_GE) {
<     col=2; /*green*/
<     thi=3;
<   }
<   else {
<     col=0; /*black*/
<     thi=1;
<   }
<   draw_line (e0b_x+65, e0b_y+360,             e0b_x+80, e0b_y+360,     thi, col);
<   draw_arrow(e0b_x+65, e0b_y+360,             e0b_x+65, e0b_y-40,      thi, col);
<   snprintf(opcd, E0LABELMAX, "%s-%d-%d", mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":mex0op==OP_ALWAYS?"AL":"NA", mex0init, mex0dist);
<   draw_text(e0b_x+30, e0b_y-40, opcd, 1, 0);
< 
4297,4300c4073
<          int eaobrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	 int mex1op,
< 	 int mex1init,
< 	 int mex1dist
---
>          int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
4363,4365c4136
< 
<   /* feedback-loop */
<   if (ea1bs & 1) {
---
>   if (ea1bs & 1) { /* feedback-loop */
4376,4390d4146
< 
<   /* mex-loop */
<   if (mex1op==OP_CMPA_LE || mex1op==OP_CMPA_GE) {
<     col=2; /*green*/
<     thi=3;
<   }
<   else {
<     col=0; /*black*/
<     thi=1;
<   }
<   draw_line (e1b_x+65, e1b_y+360,             e1b_x+80, e1b_y+360,     thi, col);
<   draw_arrow(e1b_x+65, e1b_y+360,             e1b_x+65, e1b_y-40,      thi, col);
<   snprintf(opcd, E1LABELMAX, "%s-%d-%d", mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":mex1op==OP_ALWAYS?"AL":"NA", mex1init, mex1dist);
<   draw_text(e1b_x+30, e1b_y-40, opcd, 1, 0);
< 
4492,4500c4248,4254
< 	 int lmmi_v,
<          int ea0op,   /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
<          int mwsa,    /*:  1; 0:lmwa,  1:ea0d        */
<          int mws0,    /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
<          int mws1,    /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
<          int mws2,    /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
<          int mws3,    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
< 	 int lmm_mode,/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
< 	 Ull top
---
>          int ea0op,  /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
>          int mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
>          int mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
>          int mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
>          int mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
>          int mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
> 	 int lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
4506c4260
<   int ea0store = lmmi_v && ((ea0op&0x10)||mwsa==0);
---
>   int ea0store = (ea0op&0x10);
4509c4263
<   if (ea0store) {
---
>   if (mwsa==0) {
4520c4274
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
4535,4536c4289,4290
<   if (ea0store && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
>   else                               { col=0; /*black*/ thi=1; }
4538,4539c4292,4293
<   if (ea0store && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
4541,4542c4295,4296
<   if (ea0store && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
>   else                               { col=0; /*black*/ thi=1; }
4546c4300
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
4561,4562c4315,4316
<   if (ea0store && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
>   else                               { col=0; /*black*/ thi=1; }
4564,4565c4318,4319
<   if (ea0store && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
4567,4568c4321,4322
<   if (ea0store && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
>   else                               { col=0; /*black*/ thi=1; }
4572c4326
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
4587,4588c4341,4342
<   if (ea0store && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
>   else                               { col=0; /*black*/ thi=1; }
4590,4591c4344,4345
<   if (ea0store && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
4593,4594c4347,4348
<   if (ea0store && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
>   else                               { col=0; /*black*/ thi=1; }
4598c4352
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
4613,4614c4367,4368
<   if (ea0store && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
>   else                               { col=0; /*black*/ thi=1; }
4616,4617c4370,4371
<   if (ea0store && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
4619,4620c4373,4374
<   if (ea0store && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
>   else                               { col=0; /*black*/ thi=1; }
4625c4379
<     draw_text(lmb_x+405, lmb_y-25, "M0(N/A)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M0", 1, 0);
4628c4382
<     draw_text(lmb_x+405, lmb_y-25, "M1(64KB)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M1", 1, 0);
4631c4385
<     draw_text(lmb_x+405, lmb_y-25, "M2(32KB)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M2", 1, 0);
4634c4388
<     draw_text(lmb_x+405, lmb_y-25, "M3(16KB)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M3", 1, 0);
4637d4390
<   draw_text(lmb_x+405, lmb_y-5, (char*)top, 1, 0);
4649d4401
<          int br0s,
4652d4403
<          int br1s,
4655d4405
<          int br2s,
4657,4658c4407
<          int br3h,
<          int br3s
---
>          int br3h
4744,4748c4493
<     if (br0s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br0h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br0h].name, br0s);
<     draw_text(bri_x+365,   bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+365,   bri_y+14, id[br0h].name, 1, 0);
4824,4828c4569
<     if (br1s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br1h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br1h].name, br1s);
<     draw_text(bri_x+245,   bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+245,   bri_y+14, id[br1h].name, 1, 0);
4888,4892c4629
<     if (br2s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br2h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br2h].name, br2s);
<     draw_text(bri_x+125,   bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+125,   bri_y+14, id[br2h].name, 1, 0);
4947,4951c4684
<     if (br3s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br3h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br3h].name, br3s);
<     draw_text(bri_x+5,     bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+5,     bri_y+14, id[br3h].name, 1, 0);
diff -r /home/nakashim/proj-arm64/src/conv-c2c/emax6.h ./emax6.h
22,27c22,28
< void /*__attribute__((always_inline))*/ cex(Uint, Ull*,    Ull, Ull, Ull, Ull, Ushort);
< void /*__attribute__((always_inline))*/ ex4(Uint, Ull*,    Ull*, Uint, Ull*, Uint, Ull*, Uint, Uint, Ull*, Uint, Ull*);
< int  /*__attribute__((always_inline))*/ exe(Uint, Ull*,    Ull, Uint, Ull, Uint, Ull, Uint, Uint, Ull, Uint, Ull);
< void /*__attribute__((always_inline))*/ mex(Uint, Uchar**, Uchar*, Ull, Ull, Ull);
< void /*__attribute__((always_inline))*/ mo4(Uint, Ull,     Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
< void /*__attribute__((always_inline))*/ mop(Uint, Ull,     Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
---
> // int emit_emax6a(int mode);
> void /*__attribute__((always_inline))*/ cex(Uint, Ull*, Ull, Ull, Ull, Ull, Ushort);
> void /*__attribute__((always_inline))*/ ex4(Uint, Ull*, Ull*, Uint, Ull*, Uint, Ull*, Uint, Uint, Ull*, Uint, Ull*);
> int  /*__attribute__((always_inline))*/ exe(Uint, Ull*, Ull, Uint, Ull, Uint, Ull, Uint, Uint, Ull, Uint, Ull);
> void /*__attribute__((always_inline))*/ mo4(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
> void /*__attribute__((always_inline))*/ mop(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
> void /*__attribute__((always_inline))*/ mo2(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset1, Ull offset2, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen);
29,31c30,38
< void /*__attribute__((always_inline))*/ eam(Ull*, Ull,     Uchar);
< void /*__attribute__((always_inline))*/ eag(Ull*, Ull,     Ull);
< void /*__attribute__((always_inline))*/ mmp(Uint, Ull,     Ull*, Ull, Ull, Uint, Uint);
---
> void /*__attribute__((always_inline))*/ eag(Ull*, Ull, Ull, Uchar);
> void /*__attribute__((always_inline))*/ eag1(Ull *adr, Ull base, Ull offset1,Ull offset2, Uchar msk);
> void /*__attribute__((always_inline))*/ mmp(Uint, Ull, Ull*, Ull, Ull, Uint, Uint);
> #endif
> 
> #if DEBUG_MODE 
> void /*__attribute__((always_inline))*/ mop_debug(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
> void /*__attribute__((always_inline))*/ mop2_debug(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset1,Ull offset2, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen);
> {
70d76
< #define OP_CFMA         0x0a
125,128d130
< #define OP_CMPA_LE      1
< #define OP_CMPA_GE      2
< #define OP_ALWAYS       3
< 
179,182c181,183
< #define ITYPE_MEX   6
< #define ITYPE_MO4   7
< #define ITYPE_MOP   8
<     char type      ; /* type 0:none, 1:WHILE, 2:FOR, 3:CEX, 4:EX4, 5:EXE, 6:MEX, 7:MO4, 8:MOP */
---
> #define ITYPE_MO4   6
> #define ITYPE_MOP   7
>     char type      ; /* type 0:none, 1:WHILE, 2:FOR, 3:CEX, 4:EX4, 5:EXE, 6:MO4, 7:MOP */
235,255d235
<   struct mex {
<     char op        ; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<     Ull  init   : 1; /* mex(sparse matrix) 0:none, 1:INIT0? */
<     char src1v     ; /* id.type */
<     int  src1h     ; /* hash val */
<     char src1s     ; /* suffix for bdr[][][s] */
<     char src2v     ; /* id.type */
<     int  src2h     ; /* hash val */
<     char src2s     ; /* suffix for bdr[][][s] */
<     char distv     ; /* id.type */
<     int  disth     ; /* hash val */
<     char src3v     ; /* id.type */
<     int  src3h     ; /* hash val */
<     char src3s     ; /* suffix for var[s], bdr[][][s] */
<     char src4v     ; /* id.type */
<     int  src4h     ; /* hash val */
<     char src4s     ; /* suffix for var[s], bdr[][][s] */
<     char mexdv     ; /* id.type */
<     int  mexdh     ; /* hash val */
<     char mexds     ; /* suffix for var[s] */
<   } imex;
282c262
<     char offsm     ; /* 0:B0, 1:B1, ... 7:B7, 8:H0, 9:H1, 10:H2, 11:H3, 12:W0, 13:W1, 14:D0, 15:-- */
---
>     char offsm     ; /* 0:B0, 1:B1, ... 7:B7, 8:H0, 9:H1, 10:H2, 11:H3, 12:W0, 13:W1, 14:--, 15:D0 */
332,333d311
<   struct mex dmex0; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<   struct mex dmex1; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
407,414c385
<     /* sparse matrix */
<     Ull  mex0op :  2; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<     Ull  mex0init: 1; /* mex(sparse matrix) 0:none, 1:INIT0? */
<     Ull  mex0dist: 3; /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<     Ull  mex1op :  2; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<     Ull  mex1init: 1; /* mex(sparse matrix) 0:none, 1:INIT0? */
<     Ull  mex1dist: 3; /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<     Ull  dmy00  :  8;
---
>     Ull  dmy00  : 20;
429c400
<     Ull  ea1bs  :  2; /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
---
>     Ull  ea1bs  :  2; /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
diff -r /home/nakashim/proj-arm64/src/conv-c2c/emax6lib.c ./emax6lib.c
864d863
<   case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
1152,1166d1150
<   case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
<     f1.i = (Uint)(r1);
<     f2.i = (Uint)(r2>>32);
<     f3.i = (Uint)(r3>>32);
<     if (f2.i != -1 && f2.i == f3.i) {
<       f2.i = (Uint)(r2);
<       f3.i = (Uint)(r3);
<       f0.f = f1.f + (f2.f * f3.f);
<     }
<     else {
<       f0.f = f1.f;
<     }
<     t0 = f0.i;
<     ex1_outd = t0;
<     break;
1583,1608c1567
< mex(Uint op_mx, Uchar **d, Uchar *base, Ull ofs, Ull s2, Ull s1)
< {
<   Uint ss2 = s2>>32;
<   Uint ss1 = s1>>32;
< 
<   switch (op_mx) {
<   case OP_NOP:
<     *d = base;
<     break;
<   case OP_CMPA_LE:
<     *d = base + ((ss1!=0xffffffff && ss2<=ss1) ? ofs:0); /* sparse matrix */
<     break;
<   case OP_CMPA_GE:
<     *d = base + ((ss2!=0xffffffff && ss2>=ss1) ? ofs:0); /* sparse matrix */
<     break;
<   case OP_ALWAYS: /* base++ 対応 */
<     *d = base + ofs;
<     break;
<   default:
<     printf("emax6lib: mex: undefined op_mx=%d\n", op_mx);
<     break;
<   }  
< }
< 
< void /*__attribute__((always_inline))*/
< eam(Ull *ofs, Ull offset, Uchar msk)
---
> eag(Ull *adr, Ull base, Ull offset, Uchar msk)
1660c1619
<   *ofs = offset;
---
>   *adr = base + offset;
1662a1622
> 
1664c1624
< eag(Ull *adr, Ull base, Ull ofs)
---
> eag1(Ull *adr, Ull base, Ull offset1,Ull offset2, Uchar msk)
1666c1626,1690
<   *adr = base + ofs;
---
>   switch (msk) {
>   case  MSK_D0:
>     break;
>   case  MSK_W1:		
>     offset1 = offset1>>32;
>     offset2 = offset2>>32;
>     break;
>   case  MSK_W0:
>     offset1 = offset1&0x00000000ffffffffLL;
>     offset2 = offset2&0x00000000ffffffffLL;
>     break;
>   case  MSK_H3:
>     offset1 = offset1>>48&0x000000000000ffffLL;
>     offset2 = offset2>>48&0x000000000000ffffLL;
>     break;
>   case  MSK_H2:
>     offset1 = offset1>>32&0x000000000000ffffLL;
>     offset2 = offset2>>32&0x000000000000ffffLL;
>     break;
>   case  MSK_H1:
>     offset1 = offset1>>16&0x000000000000ffffLL;
>     offset2 = offset2>>16&0x000000000000ffffLL;
>     break;
>   case  MSK_H0:
>     offset1 = offset1&0x000000000000ffffLL;
>     offset2 = offset2&0x000000000000ffffLL;
>     break;
>   case  MSK_B7:
>     offset1 = offset1>>56&0x00000000000000ffLL;
>     offset2 = offset2>>56&0x00000000000000ffLL;
>     break;
>   case  MSK_B6:
>     offset1 = offset1>>48&0x00000000000000ffLL;
>     offset2 = offset2>>48&0x00000000000000ffLL;
>     break;
>   case  MSK_B5:
>     offset1 = offset1>>40&0x00000000000000ffLL;
>     offset2 = offset2>>40&0x00000000000000ffLL;
>     break;
>   case  MSK_B4:
>     offset1 = offset1>>32&0x00000000000000ffLL;
>     offset2 = offset2>>32&0x00000000000000ffLL;
>     break;
>   case  MSK_B3:
>     offset1 = offset1>>24&0x00000000000000ffLL;
>     offset2 = offset2>>24&0x00000000000000ffLL;
>     break;
>   case  MSK_B2:
>     offset1 = offset1>>16&0x00000000000000ffLL;
>     offset2 = offset2>>16&0x00000000000000ffLL;
>     break;
>   case  MSK_B1:
>     offset1 = offset1>>8&0x00000000000000ffLL;
>     offset2 = offset2>>8&0x00000000000000ffLL;
>     break;
>   case  MSK_B0:
>     offset1 = offset1&0x00000000000000ffLL;
>     offset2 = offset2&0x00000000000000ffLL;
>     break;
>   default:
>     printf("emax6lib: eag: undefined msk=%d\n", msk);
>     break;
>   }
> 
>   *adr = base + offset1 + offset2;
1672c1696,1787
<   Ull adr, ofs;
---
>   Ull adr;
> 
>   eag(&adr, base, offset, msk);
>   mmp(op_mm, ex, d, adr, top, len, blk);
> }
> 
> void /*__attribute__((always_inline))*/
> mop_debug(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen)
> {
>   Ull adr,*load64;
>   Uint *load32;
>   Uint tmp,tmp1;
> 
>   eag(&adr, base, offset, msk);
>   
>   switch(op_mm){
>     case OP_LDR:
>       load64 = (Ull*)(adr&~7LL);
>       //Ullとしてlaod64を読む 二つのfloatをUintに直す
>       tmp = (Uint)(*load64>>32);
>       tmp1 = (Uint)(*load64);
>       
>       float load64_left = *(float*)&(tmp) ;
>       float load64_right = *(float*)&(tmp1) ;
>       load64_left += 1.0;
>       load64_right += 1.0;
>       *((Uint*)(adr&~7LL)+1) = *(Uint*)&load64_left;
>       *((Uint*)(adr&~7LL)  ) = *(Uint*)&load64_right;
>       break;
> 
> 
>     case OP_LDUWR:
> 
>       load32 = (Uint*)(adr&~3LL);
>       float load32_1 = *(float*)&(*load32) ;
>       load32_1 += 1.0;
>       // いらん　*((Uint*)(adr&~3LL)+1) = *(Uint*)&load32;
>       *((Uint*)(adr&~3LL)  ) = *(Uint*)&load32_1;
>       break;
> 
> 
> 
>   }
> 
> }
> 
> 
> void /*__attribute__((always_inline))*/
> mop2_debug(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset1,Ull offset2, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen)
> {
>   Ull adr,*load64;
>   Uint *load32;
>   Uint tmp,tmp1;
> 
>   eag1(&adr, base, offset1, offset2, msk);
>   
>   switch(op_mm){
>     case OP_LDR:
>       load64 = (Ull*)(adr&~7LL);
>       //Ullとしてlaod64を読む 二つのfloatをUintに直す
>       tmp = (Uint)(*load64>>32);
>       tmp1 = (Uint)(*load64);
>       
>       float load64_left = *(float*)&(tmp) ;
>       float load64_right = *(float*)&(tmp1) ;
>       load64_left += 1.0;
>       load64_right += 1.0;
>       *((Uint*)(adr&~7LL)+1) = *(Uint*)&load64_left;
>       *((Uint*)(adr&~7LL)  ) = *(Uint*)&load64_right;
>       break;
> 
> 
>     case OP_LDUWR:
> 
>       load32 = (Uint*)(adr&~3LL);
>       float load32_1 = *(float*)&(*load32) ;
>       load32_1 += 1.0;
>       // いらん　*((Uint*)(adr&~3LL)+1) = *(Uint*)&load32;
>       *((Uint*)(adr&~3LL)  ) = *(Uint*)&load32_1;
>       break;
> 
> 
> 
>   }
> 
> }
> 
> 
> void /*__attribute__((always_inline))*/
> mo2(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset1, Ull offset2, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen)
> {
>   Ull adr;
1674,1675c1789
<   eam(&ofs, offset, msk);
<   eag(&adr, base, ofs);
---
>   eag1(&adr, base, offset1,offset2, msk);
1682c1796
<   Ull adr, ofs;
---
>   Ull adr;
1684,1685c1798
<   eam(&ofs, offset, msk);
<   eag(&adr, base, ofs);
---
>   eag(&adr, base, offset, msk);
1705c1818
<   if (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGINE) {
---
>   if (adr < top || adr >= top+len*sizeof(Uint)) {
Only in ./: emax6.o
Only in ./: lex.yy.c
diff -r /home/nakashim/proj-arm64/src/conv-c2c/main.c ./main.c
11c11,12
< #include "conv-c2c.h"
---
> #include "yacc_lex_util.h"
> 
59a61
>   yydebug = 1;
Only in ./: main.o
diff -r /home/nakashim/proj-arm64/src/conv-c2c/Makefile ./Makefile
17c17
< OBJS	      = main.o \
---
> OBJS	      =  \
19c19,21
< 		emax6.o
---
> 		emax6.o \
> 		yacc_lex_util.o \
> 		main.o\
35c37
< 		yacc conv-c2c.y
---
> 		bison  -t -v -y -d conv-c2c.y
38c40
< 		lex -l conv-c2c.l
---
> 		flex  conv-c2c.l
40c42
< clean:;		@rm -f $(OBJS) y.tab.c lex.yy.c core mon.out Make.log *~
---
> clean:;		@rm -f $(OBJS) y.tab.c y.tab.h lex.yy.c core mon.out y.output Make.log *~
44,45c46,47
< main.o:		conv-c2c.h
< y.tab.o:	conv-c2c.h emax6.h lex.yy.c
---
> main.o:		yacc_lex_util.h
> y.tab.o:	lex.yy.c yacc_lex_util.h
46a49
> yacc_lex_util.o: conv-c2c.h emax6.h
diff -r /home/nakashim/proj-arm64/src/conv-c2c/RCS/conv-c2c.l,v ./RCS/conv-c2c.l,v
1c1
< head	1.38;
---
> head	1.37;
5c5
< 	nakashim:1.38; strict;
---
> 	nakashim:1.37; strict;
9,13d8
< 1.38
< date	2021.09.21.07.42.10;	author nakashim;	state Exp;
< branches;
< next	1.37;
< 
204c199
< 1.38
---
> 1.37
250d244
< mex                  { return(CGRA_MEX); }
414,422d407
< @
< 
< 
< 1.37
< log
< @*** empty log message ***
< @
< text
< @d42 1
diff -r /home/nakashim/proj-arm64/src/conv-c2c/RCS/conv-c2c.y,v ./RCS/conv-c2c.y,v
1c1
< head	1.89;
---
> head	1.88;
5c5
< 	nakashim:1.89; strict;
---
> 	nakashim:1.88; strict;
9,13d8
< 1.89
< date	2021.09.21.07.42.10;	author nakashim;	state Exp;
< branches;
< next	1.88;
< 
459c454
< 1.89
---
> 1.88
478,481c473,475
< %token  CGRA_ULL     CGRA_UINT    CGRA_SLL   CGRA_SRL
< %token  CGRA_WHILE   CGRA_FOR
< %token  CGRA_CEX     CGRA_EX4     CGRA_EXE
< %token  CGRA_MEX     CGRA_MO4     CGRA_MOP
---
> %token  CGRA_ULL     CGRA_UINT     CGRA_SLL   CGRA_SRL
> %token  CGRA_WHILE   CGRA_FOR      CGRA_CEX
> %token	CGRA_EX4     CGRA_EXE      CGRA_MO4   CGRA_MOP
609c603
< 	    fprintf(stderr, "in %s: for() INIT#/LOOP# mismatch\n", id[current_prefix].name);
---
> 	    fprintf(stderr, "in %s: for() includes INIT#/LOOP# mismatch\n", id[current_prefix].name);
669c663
< 	  insn[last_insn].icex.bit1v   = id[$11].type;
---
> 	  insn[last_insn].icex.bit1v   = id[ $11].type;
676c670
< 	  insn[last_insn].icex.cexdv   = id[ $5].type;
---
> 	  insn[last_insn].icex.cexdv   = id[$5].type;
688,689c682,683
< 	  insn[last_insn].iheader.row  = id[ $5].type==T_ALRNO?(id[$5].val):id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $5].type==T_ALRNO?(        -1):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val):id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(        -1):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
699c693
< 	  insn[last_insn].iexe.src2v   = id[$11].type;
---
> 	  insn[last_insn].iexe.src2v   = id[ $11].type;
725,726c719,720
< 	  insn[last_insn].iheader.row  = id[ $5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
735c729
< 	  insn[last_insn].iexe.src2v   = id[$11].type;
---
> 	  insn[last_insn].iexe.src2v   = id[ $11].type;
764c758
< 	    fprintf(stderr, "in %s: exe(INIT0?src1:src1) src1 should be the same\n", id[current_prefix].name);
---
> 	    fprintf(stderr, "in %s: exe(INIT0?src1:src1) should be specified\n", id[current_prefix].name);
768,769c762,763
< 	  insn[last_insn].iheader.row  = id[ $5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
803,804c797,798
< 	  insn[last_insn].iheader.row  = id[ $5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
813c807
< 	  insn[last_insn].iexe.src2v   = id[$11].type;
---
> 	  insn[last_insn].iexe.src2v   = id[ $11].type;
844,845c838,839
< 	  insn[last_insn].iheader.row  = id[ $5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
853,854c847,848
< 	  insn[last_insn].iexe.src1e   = id[$13].val;
< 	  insn[last_insn].iexe.src2v   = id[$15].type;
---
> 	  insn[last_insn].iexe.src1e   = id[ $13].val;
> 	  insn[last_insn].iexe.src2v   = id[ $15].type;
885,886c879,880
< 	  insn[last_insn].iheader.row  = id[ $5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
895c889
< 	  insn[last_insn].iexe.src2v   = id[$13].type;
---
> 	  insn[last_insn].iexe.src2v   = id[ $13].type;
909,963d902
<         | CGRA_MEX "(" expr "," mex_dst "," INITNO "?" XVARIABLE ":" XVARIABLE "," INITNO "?" expr ":" expr "," mex_src3 "," mex_src4 ")" ";" {
< 	  /* mex(OP_CMPA_LE, &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
< 	  /* mex(OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
< 	  /* mop(OP_LDR, 3,  &BR[r][2][1], b0[h],       bofs, MSK_W1, b,          2*LP*RMGRP,  0, 0, NULL, 2*LP*RMGRP); */
< 	  /* mop(OP_LDR, 3,  &BR[r][2][0], a0[h][CHIP], cofs, MSK_W1, a[h][CHIP], 2*LP,        0, 0, NULL, 2*LP); */
< 	  int loop_no0 = id[$7].val;
<           if (last_insn >= INSN_DEPTH) {
< 	    fprintf(stderr, "in %s: last_insn exceeds INSN_DEPTH=%d\n", id[current_prefix].name, INSN_DEPTH);
<             exit(1);
<           }
< 	  if (loop_no0 != 0) {
< 	    fprintf(stderr, "in %s: mex(INIT0) should be specified\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if ($5 != $11) {
< 	    fprintf(stderr, "in %s: exe(dst,INIT0?src1:src2) dst and src2 should be the same\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if (loop_no0 != id[$13].val) {
< 	    fprintf(stderr, "in %s: mex() INIT# mismatch\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if (id[$15].val != 0) {
< 	    fprintf(stderr, "in %s: mex(INIT0?expr1:expr2) expr1 should be zero\n", id[current_prefix].name);
<             exit(1);
< 	  }
< 	  if (id[$19].val != id[$21].val) {
< 	    fprintf(stderr, "in %s: mex(src3[%d][%d],src4[%d][%d]) should be the same row/col\n", id[current_prefix].name, (Uint)id[$19].val/EMAX_WIDTH, (Uint)id[$19].val%EMAX_WIDTH, (Uint)id[$21].val/EMAX_WIDTH, (Uint)id[$21].val%EMAX_WIDTH);
<             exit(1);
< 	  }
< 	  if (insn[last_insn].imex.src3s != 1 || insn[last_insn].imex.src4s != 0) {
< 	    fprintf(stderr, "in %s: mex(src3[%d][%d][%d],src4[%d][%d][%d]) should be src3[][][1] and src4[][][0]\n", id[current_prefix].name, (Uint)id[$19].val/EMAX_WIDTH, (Uint)id[$19].val%EMAX_WIDTH, insn[last_insn].imex.src3s, (Uint)id[$21].val/EMAX_WIDTH, (Uint)id[$21].val%EMAX_WIDTH, insn[last_insn].imex.src4s);
<             exit(1);
< 	  }
< 	  insn[last_insn].iheader.type = 6; /* MEX */
< 	  insn[last_insn].iheader.row  = id[$19].type==T_BDRNO?(id[$19].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$19].type==T_BDRNO?(id[$19].val%EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].imex.op      = id[ $3].val; /* activate self_update */
< 	  insn[last_insn].imex.init    = 1;           /* activate INIT0?src1 */
< 	  insn[last_insn].imex.src1v   = id[ $9].type;
< 	  insn[last_insn].imex.src1h   = $9;
< 	  insn[last_insn].imex.src1s   = -1;
< 	  insn[last_insn].imex.src2v   = id[$11].type;
< 	  insn[last_insn].imex.src2h   = $15;
< 	  insn[last_insn].imex.src2s   = -1;
< 	  insn[last_insn].imex.distv   = id[$17].type;
< 	  insn[last_insn].imex.disth   = $17;
< 	  insn[last_insn].imex.src3v   = id[$19].type;
< 	  insn[last_insn].imex.src3h   = $19;
< 	  insn[last_insn].imex.src4v   = id[$21].type;
< 	  insn[last_insn].imex.src4h   = $25;
< 	  insn[last_insn].imex.mexdv   = id[ $5].type;
< 	  insn[last_insn].imex.mexdh   = $5;
<           last_insn++;
<         }
971,973c910,912
< 	  insn[last_insn].iheader.type = 7; /* MO4 */
< 	  insn[last_insn].iheader.row  = id[ $7].type==T_ALRNO?(id[$7].val):id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $7].type==T_ALRNO?(        -1):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.type = 6; /* MO4 */
> 	  insn[last_insn].iheader.row  = id[$7].type==T_ALRNO?(id[$7].val):id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$7].type==T_ALRNO?(        -1):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
1001,1003c940,941
< 	      insn[last_insn].imex.op      = OP_ALWAYS;
< 	      insn[last_insn].imex.distv   = T_IMMEDIATE;
< 	      insn[last_insn].imex.disth   = hash_reg_immediate(size);
---
> 	      insn[last_insn].imop.offsv   = T_IMMEDIATE;
> 	      insn[last_insn].imop.offsh   = hash_reg_immediate(size);
1016,1018c954,956
< 	    insn[last_insn].imex.op      = OP_ALWAYS;
< 	    insn[last_insn].imex.distv   = T_IMMEDIATE;
< 	    insn[last_insn].imex.disth   = hash_reg_immediate(32LL);
---
> 	    insn[last_insn].imop.offsv   = T_IMMEDIATE;
> 	    insn[last_insn].imop.offsh   = hash_reg_immediate(32LL);
> 	    insn[last_insn].imop.offss   = -1;
1041,1043c979,981
< 	  insn[last_insn].iheader.type = 8; /* MOP */
< 	  insn[last_insn].iheader.row  = id[ $7].type==T_ALRNO?(id[$7].val)                :id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[ $7].type==T_ALRNO?(insn[last_insn].imop.mopds):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
---
> 	  insn[last_insn].iheader.type = 7; /* MOP */
> 	  insn[last_insn].iheader.row  = id[$7].type==T_ALRNO?(id[$7].val)                :id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
> 	  insn[last_insn].iheader.col  = id[$7].type==T_ALRNO?(insn[last_insn].imop.mopds):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
1075,1077c1013,1014
< 	      insn[last_insn].imex.op      = OP_ALWAYS;
< 	      insn[last_insn].imex.distv   = T_IMMEDIATE;
< 	      insn[last_insn].imex.disth   = hash_reg_immediate(size);
---
> 	      insn[last_insn].imop.offsv   = T_IMMEDIATE;
> 	      insn[last_insn].imop.offsh   = hash_reg_immediate(size);
1261,1298d1197
< mex_src1 : XVARIABLE {
< 	  insn[last_insn].imex.src1s = -1;
<           $$ = $1;
<         }
<         ;
< 
< mex_src2 : XVARIABLE {
< 	  insn[last_insn].imex.src2s = -1;
<           $$ = $1;
<         }
<         ;
< 
< mex_src3 : expr {
< 	  insn[last_insn].iexe.src3s = -1;
<           $$ = $1;
<         }
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
< 	  insn[last_insn].imex.src3s = id[$3].val;
<           $$ = $1;
<         }
<         ;
< 
< mex_src4 : expr {
< 	  insn[last_insn].iexe.src4s = -1;
<           $$ = $1;
<         }
<         | BDRNO "\[" expr "\]" { /* BR[r][c][s] */
< 	  insn[last_insn].imex.src4s = id[$3].val;
<           $$ = $1;
<         }
<         ;
< 
< mex_dst : "\&" XVARIABLE {
< 	  insn[last_insn].imex.mexds = -1;
<           $$ = $2;
< 	}
< 	;
< 
1345c1244
< 	  insn[last_insn].imop.updt  = 1;
---
> 	  insn[last_insn].imop.updt = 1;
1350c1249
< 	  insn[last_insn].imop.updt  = 1;
---
> 	  insn[last_insn].imop.updt = 1;
1683,1778d1581
< @
< 
< 
< 1.88
< log
< @*** empty log message ***
< @
< text
< @d15 4
< a18 3
< %token  CGRA_ULL     CGRA_UINT     CGRA_SLL   CGRA_SRL
< %token  CGRA_WHILE   CGRA_FOR      CGRA_CEX
< %token	CGRA_EX4     CGRA_EXE      CGRA_MO4   CGRA_MOP
< d146 1
< a146 1
< 	    fprintf(stderr, "in %s: for() includes INIT#/LOOP# mismatch\n", id[current_prefix].name);
< d206 1
< a206 1
< 	  insn[last_insn].icex.bit1v   = id[ $11].type;
< d213 1
< a213 1
< 	  insn[last_insn].icex.cexdv   = id[$5].type;
< d225 2
< a226 2
< 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val):id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(        -1):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
< d236 1
< a236 1
< 	  insn[last_insn].iexe.src2v   = id[ $11].type;
< d262 2
< a263 2
< 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
< d272 1
< a272 1
< 	  insn[last_insn].iexe.src2v   = id[ $11].type;
< d301 1
< a301 1
< 	    fprintf(stderr, "in %s: exe(INIT0?src1:src1) should be specified\n", id[current_prefix].name);
< d305 2
< a306 2
< 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
< d340 2
< a341 2
< 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
< d350 1
< a350 1
< 	  insn[last_insn].iexe.src2v   = id[ $11].type;
< d381 2
< a382 2
< 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
< d390 2
< a391 2
< 	  insn[last_insn].iexe.src1e   = id[ $13].val;
< 	  insn[last_insn].iexe.src2v   = id[ $15].type;
< d422 2
< a423 2
< 	  insn[last_insn].iheader.row  = id[$5].type==T_ALRNO?(id[$5].val)                :id[$5].type==T_BDRNO?(id[$5].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$5].type==T_ALRNO?(insn[last_insn].iexe.exeds):id[$5].type==T_BDRNO?(id[$5].val%EMAX_WIDTH):-1; /* adr/bdr */
< d432 1
< a432 1
< 	  insn[last_insn].iexe.src2v   = id[ $13].type;
< d446 55
< d508 3
< a510 3
< 	  insn[last_insn].iheader.type = 6; /* MO4 */
< 	  insn[last_insn].iheader.row  = id[$7].type==T_ALRNO?(id[$7].val):id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$7].type==T_ALRNO?(        -1):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
< d538 3
< a540 2
< 	      insn[last_insn].imop.offsv   = T_IMMEDIATE;
< 	      insn[last_insn].imop.offsh   = hash_reg_immediate(size);
< d553 3
< a555 3
< 	    insn[last_insn].imop.offsv   = T_IMMEDIATE;
< 	    insn[last_insn].imop.offsh   = hash_reg_immediate(32LL);
< 	    insn[last_insn].imop.offss   = -1;
< d578 3
< a580 3
< 	  insn[last_insn].iheader.type = 7; /* MOP */
< 	  insn[last_insn].iheader.row  = id[$7].type==T_ALRNO?(id[$7].val)                :id[$7].type==T_BDRNO?(id[$7].val/EMAX_WIDTH):-1; /* adr/bdr */
< 	  insn[last_insn].iheader.col  = id[$7].type==T_ALRNO?(insn[last_insn].imop.mopds):id[$7].type==T_BDRNO?(id[$7].val%EMAX_WIDTH):-1; /* adr/bdr */
< d612 3
< a614 2
< 	      insn[last_insn].imop.offsv   = T_IMMEDIATE;
< 	      insn[last_insn].imop.offsh   = hash_reg_immediate(size);
< d798 38
< d882 1
< a882 1
< 	  insn[last_insn].imop.updt = 1;
< d887 1
< a887 1
< 	  insn[last_insn].imop.updt = 1;
diff -r /home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v ./RCS/emax6.c,v
1c1
< head	1.89;
---
> head	1.87;
5c5
< 	nakashim:1.89; strict;
---
> 	nakashim:1.87; strict;
9,18d8
< 1.89
< date	2021.09.21.07.42.15;	author nakashim;	state Exp;
< branches;
< next	1.88;
< 
< 1.88
< date	2021.08.11.10.54.45;	author nakashim;	state Exp;
< branches;
< next	1.87;
< 
459c449
< 1.89
---
> 1.87
465c455
< static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.88 2021/08/11 10:54:45 nakashim Exp nakashim $";
---
> static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.86 2021/06/18 03:04:05 nakashim Exp nakashim $";
483d472
<   int last_mex = -1; /* 0:mex0, 1:mex1 */
488d476
<   struct mex *dmex0, *dmex1;
1067d1054
<       case OP_CFMA:   /* 3 */
1285,1378d1271
<     case ITYPE_MEX: /* MEX */
<       /* mex(OP_CMPA_LE, &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
<       /* mex(OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
<       /* mop(OP_LDR, 3,  &BR[r][2][1], b0[h],       bofs, MSK_W1, b,          2*LP*RMGRP,  0, 0, NULL, 2*LP*RMGRP); */
<       /* mop(OP_LDR, 3,  &BR[r][2][0], a0[h][CHIP], cofs, MSK_W1, a[h][CHIP], 2*LP,        0, 0, NULL, 2*LP); */
<       switch (insn[i].imex.op) {
<       case OP_CMPA_LE:
<       case OP_CMPA_GE:
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src3v, insn[i].imex.src3h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src4v, insn[i].imex.src4h, rdep);
<         break;
<       case OP_ALWAYS:
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
<         get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
<         break;
<       }
< 
<       folding = 1; /* set */
< 
<       if (row < 0) { /* OP_ALWAYSの場合,BR[][]指定無し */
<         /* 1-2a */
< 	if (last_row < *rdep) { /* 間を空けて配置可能 */
< 	  last_row = *rdep;
< 	  last_col = 0;
< 	}
< 	else { /* last_row >= *rdep *//* 最終位置と依存関係制約位置が一致 */
< 	  last_col++; /* overflowはあとで検査.EXEがWIDTH以上あれば次段へ移動 */
< 	  if (last_col >= EMAX_WIDTH) {
< 	    last_row++;
< 	    last_col = 0;
< 	  }
< 	}
<       }
<       else { /* WHILE/ALR/BDR is specified */
<         /* 1-2b */
<         if (row < *rdep) {
< 	  printf("in %s: mex cannot locate destination BDRNO (row=%d)\n", id[current_prefix].name, row);
< 	  exit(1);
< 	}
< 	else if (row < last_row) {
<           printf("in %s: mex found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
<           exit(1);
<         }
<         else {
<           last_row = row;
<           last_col = col;
<         }
<       }
<       /* 1-3 */
<       //printf("ITYPE_MEX: row=%d col=%d rdep=%d last_row=%d last_col=%d\n", row, col, *rdep, last_row, last_col);
<       if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
<         printf("in %s: [%d][%d] mex exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
<         exit(1);
<       }
<       if      (!dec[last_row][last_col].dmex1.op)
< 	last_mex = 1;
<       else if (!dec[last_row][last_col].dmex0.op)
< 	last_mex = 0;
<       else {
<         printf("in %s: [%d][%d] mex conflicts\n", id[current_prefix].name, last_row, last_col);
<         exit(1);
<       }
<       /* 1-4 */
<       dmex0 = &dec[last_row][last_col].dmex0;
<       dmex1 = &dec[last_row][last_col].dmex1;
<       if (last_mex==1) /* load */
<         *dmex1 = insn[i].imex;
<       else /* store/load */
<         *dmex0 = insn[i].imex;
<       /* 1-5 */
<       /* BR[][][1],BR[][][0]からの戻りは常時接続なのでselector追加不要 */
<       /* ea14woofs,ea04woofsからの戻りは常時接続なのでselector追加不要 */
<       if (last_mex==1) { /* first */
<         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmex1->src1v, dmex1->src1h, dmex1->src1s);
<       }
<       else { /* second */
<         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmex0->src1v, dmex0->src1h, dmex0->src1s);
<       }
<       /* 1-6 */
<       /* BR[][][1],BR[][][0]からの戻りは常時接続なのでbus設定不要 */
<       /* ea14woofs,ea04woofsからの戻りは常時接続なのでbus設定不要 */
<       if (last_mex==1) { /* first */
< 	/* do nothing */
<       }
<       else { /* second */
< 	/* do nothing */
<       }
<       id[insn[i].imex.mexdh].itype = ITYPE_MEX;
<       id[insn[i].imex.mexdh].row   = last_row;
<       id[insn[i].imex.mexdh].col   = last_col;
<       insn[i].iheader.fixed = 1;
<       break;
1487,1488c1380,1381
<         dmop1->updt  = 1;            /* for internal update of ea1 */
<         dmop1->offsm = 14;           /* for internal update of ea1 */
---
>         dmop1->updt  = 1;  /* for internal update of ea1 */
>         dmop1->offsm = 15; /* for internal update of ea1 */
1492,1493c1385,1386
<         dmop1->updt  = 1;            /* for internal update of ea1 */
<         dmop1->offsm = 14;           /* for internal update of ea1 */
---
>         dmop1->updt  = 1;  /* for internal update of ea1 */
>         dmop1->offsm = 15; /* for internal update of ea1 */
1504c1397
< 	set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
---
>         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
1949,1955d1841
<           int mex2_and_op0_is_empty = (op1 && !op0) && (typ == MTYPE_RLOAD)
<                                    && (typ == insn[i].imop.mtype)
<                                    && (blk == insn[i].imop.blk)
<                                    && (fcev== insn[i].imop.forcev)
<                                    && (fceh== insn[i].imop.forceh)
< 	                           && (dec[last_row][last_col].dmex0.op)
< 	                           && (dec[last_row][last_col].dmex1.op);
1958,1959d1843
< 	  else if (mex2_and_op0_is_empty) /* mex should merge op1(map to LMM/col2) and op0(map to LMM/col1) w/ different top */
< 	    last_mop = 0; /* mex load */
1982,1983d1865
<       dmex0 = &dec[last_row][last_col].dmex0;
<       dmex1 = &dec[last_row][last_col].dmex1;
1986c1868
<       if (last_mop==1) { /* load */
---
>       if (last_mop==1) /* load */
1988,1995c1870
< 	if (dmex1->op && insn[i].imex.op) {
< 	  printf("in %s: [%d][%d] mex1 & mop1(adr++) conflicts\n", id[current_prefix].name, last_row, last_col);
< 	  exit(1);
< 	}
< 	else if (insn[i].imex.op)
< 	  *dmex1 = insn[i].imex;
<       }
<       else { /* store/load */
---
>       else /* store/load */
1997,2003d1871
< 	if (dmex0->op && insn[i].imex.op) {
< 	  printf("in %s: [%d][%d] mex0 & mop0(adr++) conflicts\n", id[current_prefix].name, last_row, last_col);
< 	  exit(1);
< 	}
< 	else if (insn[i].imex.op)
< 	  *dmex0 = insn[i].imex;
<       }
2013,2014c1881
< 	if (!(dmex1->op && dmex1->mexdh == dmop1->baseh))
< 	  set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
---
>         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
2020,2022d1886
<           if (dmop1->mtype == MTYPE_RLOAD && dmex1->op == OP_CMPA_LE || dmex1->op == OP_CMPA_GE) {
< 	    //printf("MOP1 CMPA RLOAD\n");
< 	  }
2097,2098c1961
< 	if (!(dmex0->op && dmex0->mexdh == dmop0->baseh))
< 	  set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
---
>         set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
2101,2104c1964
< 	  int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
< 	  int f  = id[dmop0->forceh].val;
< 	  int p  = 0; /* initial value */
<           if (dmop0->mtype == MTYPE_RLOAD && !(dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE)) {
---
>           if (insn[i].imop.mtype == MTYPE_RLOAD) {
2107,2119c1967,1970
<           else { /* includes dmop0->mtype == MTYPE_RLOAD && (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) */
< 	    int last_col_mex;
< 	    if (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) {
< 	      //printf("MOP0 CMPA RLOAD\n");
< 	      if (last_col < 2) {
< 		printf("in %s: [%d][%d] mex0 should be located col>=2\n", id[current_prefix].name, last_row, last_col);
< 		exit(1);
< 	      }
< 	      last_col_mex = last_col-1;
< 	      printf("dmex0.lmm moved from col%d to col%d ", last_col, last_col_mex);
< 	    }
< 	    else /* normal mop w/o mex */
< 	      last_col_mex = last_col;
---
>           else {
> 	    int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
> 	    int f  = id[dmop0->forceh].val;
> 	    int p  = 0; /* initial value */
2121,2139c1972,1990
< 	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
< 	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
< 	    case 6: /* lmx */                                     conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
< 	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
< 	    }
< 	    conf[last_row][last_col_mex].cdw2.lmm_mode = 3;
<             lmmi[last_row][last_col_mex].v     = 1;
<             lmmi[last_row][last_col_mex].rw    = rw;
<             lmmi[last_row][last_col_mex].f     = f;
<             lmmi[last_row][last_col_mex].p     = p;
<             lmmi[last_row][last_col_mex].blk   = dmop0->blk;
< 	    lmmi[last_row][last_col_mex].cidx  = id[dmop0->toph].cidx;
<             lmmi[last_row][last_col_mex].len   = id[dmop0->lenh].val-1;
<             lmmi[last_row][last_col_mex].ofs   = 0; /* initial value */
<             lmmi[last_row][last_col_mex].top   = (Ull)id[dmop0->toph].name;
<             lmmx[last_row][last_col_mex].forcev= dmop0->forcev;
<             lmmx[last_row][last_col_mex].forceh= dmop0->forceh;
<             lmmx[last_row][last_col_mex].lenv  = dmop0->lenv;
<             lmmx[last_row][last_col_mex].lenh  = dmop0->lenh;
---
> 	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
> 	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
> 	    case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
> 	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
> 	    }
> 	    conf[last_row][last_col].cdw2.lmm_mode = 3;
>             lmmi[last_row][last_col].v     = 1;
>             lmmi[last_row][last_col].rw    = rw;
>             lmmi[last_row][last_col].f     = f;
>             lmmi[last_row][last_col].p     = p;
>             lmmi[last_row][last_col].blk   = dmop0->blk;
> 	    lmmi[last_row][last_col].cidx  = id[dmop0->toph].cidx;
>             lmmi[last_row][last_col].len   = id[dmop0->lenh].val-1;
>             lmmi[last_row][last_col].ofs   = 0; /* initial value */
>             lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
>             lmmx[last_row][last_col].forcev= dmop0->forcev;
>             lmmx[last_row][last_col].forceh= dmop0->forceh;
>             lmmx[last_row][last_col].lenv  = dmop0->lenv;
>             lmmx[last_row][last_col].lenh  = dmop0->lenh;
2303d2153
<       //printf("conf[%d][%d]: init=%d fold=%d\n", i, j, conf[i][j].cdw0.init, conf[i][j].cdw0.fold);
2312,2335d2161
< 
<       /* mex0/mop0 */
<       conf[i][j].cdw0.mex0op   = dec[i][j].dmex0.op;
<       conf[i][j].cdw0.mex0init = dec[i][j].dmex0.init;
<       switch (id[dec[i][j].dmex0.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<       case  0: conf[i][j].cdw0.mex0dist = 0; break;
<       case  1: conf[i][j].cdw0.mex0dist = 1; break;
<       case  2: conf[i][j].cdw0.mex0dist = 2; break;
<       case  4: conf[i][j].cdw0.mex0dist = 3; break;
<       case  8: conf[i][j].cdw0.mex0dist = 4; break;
<       case 16: conf[i][j].cdw0.mex0dist = 5; break;
<       case 32: conf[i][j].cdw0.mex0dist = 6; break;
<       default: conf[i][j].cdw0.mex0dist = 7; break;
<       }
<       /* mex0.mexdh and mop0.mopdh */
<       if (dec[i][j].dmex0.op && dec[i][j].dmex0.mexdh == dec[i][j].dmop0.baseh) {
< 	printf("[%d][%d] detected dmex0.dst==mop0.base.", i, j);
< 	                    dec[i][j].dmop0.updt  = 1;
< 	regv[i][j].ea0b_v = dec[i][j].dmop0.basev = dec[i][j].dmex0.src1v; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea0b_h = dec[i][j].dmop0.baseh = dec[i][j].dmex0.src1h; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea0b_s = dec[i][j].dmop0.bases = dec[i][j].dmex0.src1s; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
< 	printf(" mop0 renamed from %s to %s\n", id[dec[i][j].dmex0.mexdh].name, id[dec[i][j].dmop0.baseh].name);
<       }
< 
2338,2340c2164,2166
<       conf[i][j].cdw1.ea0op    = dec[i][j].dmop0.op;
<       conf[i][j].cdw1.ea0bs    = ((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
<       conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1; /* 0:ea0or, 1:eaobrs */
---
>       conf[i][j].cdw1.ea0op  = dec[i][j].dmop0.op;
>       conf[i][j].cdw1.ea0bs  =((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
>       conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1;                             /* 0:ea0or, 1:eaobrs */
2342,2366d2167
< 
<       /* mex1/mop1 */
<       conf[i][j].cdw0.mex1op   = dec[i][j].dmex1.op;
<       conf[i][j].cdw0.mex1init = dec[i][j].dmex1.init;
<       switch (id[dec[i][j].dmex1.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<       case  0: conf[i][j].cdw0.mex1dist = 0; break;
<       case  1: conf[i][j].cdw0.mex1dist = 1; break;
<       case  2: conf[i][j].cdw0.mex1dist = 2; break;
<       case  4: conf[i][j].cdw0.mex1dist = 3; break;
<       case  8: conf[i][j].cdw0.mex1dist = 4; break;
<       case 16: conf[i][j].cdw0.mex1dist = 5; break;
<       case 32: conf[i][j].cdw0.mex1dist = 6; break;
<       default: conf[i][j].cdw0.mex1dist = 7; break;
<       }
<       /* mex1.mexdh and mop1.mopdh */
<       if (dec[i][j].dmex1.op && dec[i][j].dmex1.mexdh == dec[i][j].dmop1.baseh) {
< 	printf("[%d][%d] detected dmex1.dst==mop1.base.", i, j);
< 	                    dec[i][j].dmop1.updt  = 1;
< 	regv[i][j].ea1b_v = dec[i][j].dmop1.basev = dec[i][j].dmex1.src1v; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea1b_h = dec[i][j].dmop1.baseh = dec[i][j].dmex1.src1h; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
< 	regv[i][j].ea1b_s = dec[i][j].dmop1.bases = dec[i][j].dmex1.src1s; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
< 	printf(" mop1 renamed from %s to %s\n", id[dec[i][j].dmex1.mexdh].name, id[dec[i][j].dmop1.baseh].name);
<       }
< 
<       /* ea[bo] depends on busmap[i][j].br[prev][] and decode[i][j].dmop.ex[123] */
2369c2170
<         conf[i][j].cdw1.ea1op = dec[i][j].dmop0.op;
---
>         conf[i][j].cdw1.ea1op  = dec[i][j].dmop0.op;
2371,2373c2172,2174
<         conf[i][j].cdw1.ea1op = dec[i][j].dmop1.op;
<       conf[i][j].cdw1.ea1bs  = ((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
<       conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1; /* 0:ea1or, 1:eaobrs */
---
>         conf[i][j].cdw1.ea1op  = dec[i][j].dmop1.op;
>       conf[i][j].cdw1.ea1bs  =((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
>       conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1;                             /* 0:ea1or, 1:eaobrs */
2375,2377d2175
< 
<       //printf("conf[%d][%d]: mex0=%d.%d.%d mex1=%d.%d.%d\n", i, j, conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0init, conf[i][j].cdw0.mex0dist, conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1init, conf[i][j].cdw0.mex1dist);
< 
3080a2879
>   fprintf(ofile, "\temax6.lastdist = 0;\n");
3214d3012
<   fprintf(ofile, "\t  emax6.lastdist = 0;\n");
3315c3113
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = %s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
3318c3116
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = (Ull)%s;\n", i, j, id[regv[i][j].ea0b_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s;\n", i, j, id[regv[i][j].ea0b_h].name);
3320c3118
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
3325c3123
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = %s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
3328c3126
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = (Ull)%s;\n", i, j, id[regv[i][j].ea0o_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s;\n", i, j, id[regv[i][j].ea0o_h].name);
3330c3128
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
3335c3133
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = %s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
3338c3136
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = (Ull)%s;\n", i, j, id[regv[i][j].ea1b_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s;\n", i, j, id[regv[i][j].ea1b_h].name);
3340c3138
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
3345c3143
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
---
> 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = %s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
3348c3146
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = (Ull)%s;\n", i, j, id[regv[i][j].ea1o_h].name);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s;\n", i, j, id[regv[i][j].ea1o_h].name);
3350c3148
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
---
> 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
3675,3676c3473,3474
<      /* reg_type:  ITYPE_MEX/ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
<      /* reg_loc:   ITYPE_MEX/ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
---
>      /* reg_type:  ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
>      /* reg_loc:   ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
3689c3487
<     if (insn_type == ITYPE_MEX || insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
---
>     if (insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
3692c3490
<         printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>         printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3697c3495
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3710c3508
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3725c3523
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
3736c3534
<             printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
---
>             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
4167,4176c3965,3970
<            conf[i][j].cdw1.ea0op,   /*:  5; mem_opcd */
<            conf[i][j].cdw1.ea0bs,   /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
<            conf[i][j].cdw1.ea0os,   /*:  1; 0:ea0or, 1:eaobrs */
<            conf[i][j].cdw1.ea0msk,  /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
<            conf[i][j].cdw1.eabbrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
<            conf[i][j].cdw1.eaobrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	   conf[i][j].cdw0.mex0op,  /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
< 	   conf[i][j].cdw0.mex0init,/* mex(sparse matrix) 0:none, 1:INIT0? */
< 	   conf[i][j].cdw0.mex0dist /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
< 
---
>            conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
>            conf[i][j].cdw1.ea0bs,  /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
>            conf[i][j].cdw1.ea0os,  /*:  1; 0:ea0or, 1:eaobrs */
>            conf[i][j].cdw1.ea0msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
>            conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
>            conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
4180,4188c3974,3979
<            conf[i][j].cdw1.ea1op,   /*:  5; mem_opcd */
<            conf[i][j].cdw1.ea1bs,   /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
<            conf[i][j].cdw1.ea1os,   /*:  1; 0:ea1or, 1:eaobrs */
<            conf[i][j].cdw1.ea1msk,  /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
<            conf[i][j].cdw1.eabbrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
<            conf[i][j].cdw1.eaobrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	   conf[i][j].cdw0.mex1op,  /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
< 	   conf[i][j].cdw0.mex1init,/* mex(sparse matrix) 0:none, 1:INIT0? */
< 	   conf[i][j].cdw0.mex1dist /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
---
>            conf[i][j].cdw1.ea1op,  /*:  5; mem_opcd */
>            conf[i][j].cdw1.ea1bs,  /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
>            conf[i][j].cdw1.ea1os,  /*:  1; 0:ea1or, 1:eaobrs */
>            conf[i][j].cdw1.ea1msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
>            conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
>            conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
4207,4215c3998,4004
< 	   lmmi[i][j].v,            /*:  1; valid */
<            conf[i][j].cdw1.ea0op,   /*:  5; mem_opcd */
<            conf[i][j].cdw2.mwsa,    /*:  1; 0:lmwa,  1:ea0d        */
<            conf[i][j].cdw2.mws0,    /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
<            conf[i][j].cdw2.mws1,    /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
<            conf[i][j].cdw2.mws2,    /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
<            conf[i][j].cdw2.mws3,    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
<            conf[i][j].cdw2.lmm_mode,/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
<            lmmi[i][j].top
---
>            conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
>            conf[i][j].cdw2.mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
>            conf[i][j].cdw2.mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
>            conf[i][j].cdw2.mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
>            conf[i][j].cdw2.mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
>            conf[i][j].cdw2.mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
>            conf[i][j].cdw2.lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
4227d4015
<            bus[i][j].br[0].s,
4230d4017
<            bus[i][j].br[1].s,
4233d4019
<            bus[i][j].br[2].s,
4235,4236c4021
<            bus[i][j].br[3].h,
<            bus[i][j].br[3].s
---
>            bus[i][j].br[3].h
4637,4640c4422
<          int eaobrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	 int mex0op,
< 	 int mex0init,
< 	 int mex0dist
---
>          int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
4703,4705c4485
< 
<   /* feedback-loop */
<   if (ea0bs & 1) {
---
>   if (ea0bs & 1) { /* feedback-loop */
4716,4730d4495
< 
<   /* mex-loop */
<   if (mex0op==OP_CMPA_LE || mex0op==OP_CMPA_GE) {
<     col=2; /*green*/
<     thi=3;
<   }
<   else {
<     col=0; /*black*/
<     thi=1;
<   }
<   draw_line (e0b_x+65, e0b_y+360,             e0b_x+80, e0b_y+360,     thi, col);
<   draw_arrow(e0b_x+65, e0b_y+360,             e0b_x+65, e0b_y-40,      thi, col);
<   snprintf(opcd, E0LABELMAX, "%s-%d-%d", mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":mex0op==OP_ALWAYS?"AL":"NA", mex0init, mex0dist);
<   draw_text(e0b_x+30, e0b_y-40, opcd, 1, 0);
< 
4760,4763c4525
<          int eaobrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< 	 int mex1op,
< 	 int mex1init,
< 	 int mex1dist
---
>          int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
4826,4828c4588
< 
<   /* feedback-loop */
<   if (ea1bs & 1) {
---
>   if (ea1bs & 1) { /* feedback-loop */
4839,4853d4598
< 
<   /* mex-loop */
<   if (mex1op==OP_CMPA_LE || mex1op==OP_CMPA_GE) {
<     col=2; /*green*/
<     thi=3;
<   }
<   else {
<     col=0; /*black*/
<     thi=1;
<   }
<   draw_line (e1b_x+65, e1b_y+360,             e1b_x+80, e1b_y+360,     thi, col);
<   draw_arrow(e1b_x+65, e1b_y+360,             e1b_x+65, e1b_y-40,      thi, col);
<   snprintf(opcd, E1LABELMAX, "%s-%d-%d", mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":mex1op==OP_ALWAYS?"AL":"NA", mex1init, mex1dist);
<   draw_text(e1b_x+30, e1b_y-40, opcd, 1, 0);
< 
4955,4963c4700,4706
< 	 int lmmi_v,
<          int ea0op,   /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
<          int mwsa,    /*:  1; 0:lmwa,  1:ea0d        */
<          int mws0,    /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
<          int mws1,    /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
<          int mws2,    /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
<          int mws3,    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
< 	 int lmm_mode,/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
< 	 Ull top
---
>          int ea0op,  /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
>          int mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
>          int mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
>          int mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
>          int mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
>          int mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
> 	 int lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
4969c4712
<   int ea0store = lmmi_v && ((ea0op&0x10)||mwsa==0);
---
>   int ea0store = (ea0op&0x10);
4972c4715
<   if (ea0store) {
---
>   if (mwsa==0) {
4983c4726
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
4998,4999c4741,4742
<   if (ea0store && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
>   else                               { col=0; /*black*/ thi=1; }
5001,5002c4744,4745
<   if (ea0store && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
5004,5005c4747,4748
<   if (ea0store && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
>   else                               { col=0; /*black*/ thi=1; }
5009c4752
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
5024,5025c4767,4768
<   if (ea0store && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
>   else                               { col=0; /*black*/ thi=1; }
5027,5028c4770,4771
<   if (ea0store && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
5030,5031c4773,4774
<   if (ea0store && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
>   else                               { col=0; /*black*/ thi=1; }
5035c4778
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
5050,5051c4793,4794
<   if (ea0store && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
>   else                               { col=0; /*black*/ thi=1; }
5053,5054c4796,4797
<   if (ea0store && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
5056,5057c4799,4800
<   if (ea0store && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
>   else                               { col=0; /*black*/ thi=1; }
5061c4804
<   if (ea0store) {
---
>   if (ea0store || mwsa==0) {
5076,5077c4819,4820
<   if (ea0store && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
>   else                               { col=0; /*black*/ thi=1; }
5079,5080c4822,4823
<   if (ea0store && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
>   else                               { col=0; /*black*/ thi=1; }
5082,5083c4825,4826
<   if (ea0store && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
<   else                     { col=0; /*black*/ thi=1; }
---
>   if ((ea0store || mwsa==0) && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
>   else                               { col=0; /*black*/ thi=1; }
5088c4831
<     draw_text(lmb_x+405, lmb_y-25, "M0(N/A)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M0", 1, 0);
5091c4834
<     draw_text(lmb_x+405, lmb_y-25, "M1(64KB)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M1", 1, 0);
5094c4837
<     draw_text(lmb_x+405, lmb_y-25, "M2(32KB)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M2", 1, 0);
5097c4840
<     draw_text(lmb_x+405, lmb_y-25, "M3(16KB)", 1, 0);
---
>     draw_text(lmb_x+430, lmb_y+15, "M3", 1, 0);
5100d4842
<   draw_text(lmb_x+405, lmb_y-5, (char*)top, 1, 0);
5112d4853
<          int br0s,
5115d4855
<          int br1s,
5118d4857
<          int br2s,
5120,5121c4859
<          int br3h,
<          int br3s
---
>          int br3h
5207,5211c4945
<     if (br0s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br0h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br0h].name, br0s);
<     draw_text(bri_x+365,   bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+365,   bri_y+14, id[br0h].name, 1, 0);
5287,5291c5021
<     if (br1s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br1h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br1h].name, br1s);
<     draw_text(bri_x+245,   bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+245,   bri_y+14, id[br1h].name, 1, 0);
5351,5355c5081
<     if (br2s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br2h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br2h].name, br2s);
<     draw_text(bri_x+125,   bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+125,   bri_y+14, id[br2h].name, 1, 0);
5410,5414c5136
<     if (br3s == -1)
<       snprintf(opcd, BRLABELMAX, "%s", id[br3h].name);
<     else
<       snprintf(opcd, BRLABELMAX, "%s[%d]", id[br3h].name, br3s);
<     draw_text(bri_x+5,     bri_y+14, opcd, 1, 0);
---
>     draw_text(bri_x+5,     bri_y+14, id[br3h].name, 1, 0);
5552,5864d5273
< @
< 
< 
< 1.88
< log
< @*** empty log message ***
< @
< text
< @d2 1
< a2 1
< static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.87 2021/08/11 04:45:48 nakashim Exp nakashim $";
< d20 1
< d25 1
< d604 1
< d822 94
< d1024 2
< a1025 2
<         dmop1->updt  = 1;  /* for internal update of ea1 */
<         dmop1->offsm = 15; /* for internal update of ea1 */
< d1029 2
< a1030 2
<         dmop1->updt  = 1;  /* for internal update of ea1 */
<         dmop1->offsm = 15; /* for internal update of ea1 */
< d1041 1
< a1041 1
<         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
< d1486 7
< d1495 2
< d1519 2
< d1523 1
< a1523 1
<       if (last_mop==1) /* load */
< d1525 8
< a1532 1
<       else /* store/load */
< d1534 7
< d1550 2
< a1551 1
<         set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
< d1557 3
< d1634 2
< a1635 1
<         set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
< d1638 4
< a1641 1
<           if (insn[i].imop.mtype == MTYPE_RLOAD) {
< d1644 13
< a1656 4
<           else {
< 	    int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
< 	    int f  = id[dmop0->forceh].val;
< 	    int p  = 0; /* initial value */
< d1658 19
< a1676 19
< 	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
< 	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
< 	    case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
< 	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
< 	    }
< 	    conf[last_row][last_col].cdw2.lmm_mode = 3;
<             lmmi[last_row][last_col].v     = 1;
<             lmmi[last_row][last_col].rw    = rw;
<             lmmi[last_row][last_col].f     = f;
<             lmmi[last_row][last_col].p     = p;
<             lmmi[last_row][last_col].blk   = dmop0->blk;
< 	    lmmi[last_row][last_col].cidx  = id[dmop0->toph].cidx;
<             lmmi[last_row][last_col].len   = id[dmop0->lenh].val-1;
<             lmmi[last_row][last_col].ofs   = 0; /* initial value */
<             lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
<             lmmx[last_row][last_col].forcev= dmop0->forcev;
<             lmmx[last_row][last_col].forceh= dmop0->forceh;
<             lmmx[last_row][last_col].lenv  = dmop0->lenv;
<             lmmx[last_row][last_col].lenh  = dmop0->lenh;
< d1840 1
< d1849 24
< d1875 3
< a1877 3
<       conf[i][j].cdw1.ea0op  = dec[i][j].dmop0.op;
<       conf[i][j].cdw1.ea0bs  =((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
<       conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1;                             /* 0:ea0or, 1:eaobrs */
< d1879 25
< d1906 1
< a1906 1
<         conf[i][j].cdw1.ea1op  = dec[i][j].dmop0.op;
< d1908 3
< a1910 3
<         conf[i][j].cdw1.ea1op  = dec[i][j].dmop1.op;
<       conf[i][j].cdw1.ea1bs  =((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
<       conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1;                             /* 0:ea1or, 1:eaobrs */
< d1912 3
< d2852 1
< a2852 1
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = %s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
< d2855 1
< a2855 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s;\n", i, j, id[regv[i][j].ea0b_h].name);
< d2857 1
< a2857 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
< d2862 1
< a2862 1
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = %s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
< d2865 1
< a2865 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s;\n", i, j, id[regv[i][j].ea0o_h].name);
< d2867 1
< a2867 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
< d2872 1
< a2872 1
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = %s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
< d2875 1
< a2875 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s;\n", i, j, id[regv[i][j].ea1b_h].name);
< d2877 1
< a2877 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
< d2882 1
< a2882 1
< 	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = %s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
< d2885 1
< a2885 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s;\n", i, j, id[regv[i][j].ea1o_h].name);
< d2887 1
< a2887 1
< 	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
< d3212 2
< a3213 2
<      /* reg_type:  ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
<      /* reg_loc:   ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
< d3226 1
< a3226 1
<     if (insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
< d3229 1
< a3229 1
<         printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
< d3234 1
< a3234 1
<             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
< d3247 1
< a3247 1
<             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
< d3262 1
< a3262 1
<             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
< d3273 1
< a3273 1
<             printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
< d3704 10
< a3713 6
<            conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
<            conf[i][j].cdw1.ea0bs,  /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
<            conf[i][j].cdw1.ea0os,  /*:  1; 0:ea0or, 1:eaobrs */
<            conf[i][j].cdw1.ea0msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
<            conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
<            conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< d3717 9
< a3725 6
<            conf[i][j].cdw1.ea1op,  /*:  5; mem_opcd */
<            conf[i][j].cdw1.ea1bs,  /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
<            conf[i][j].cdw1.ea1os,  /*:  1; 0:ea1or, 1:eaobrs */
<            conf[i][j].cdw1.ea1msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
<            conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
<            conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< d3744 9
< a3752 7
<            conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
<            conf[i][j].cdw2.mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
<            conf[i][j].cdw2.mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
<            conf[i][j].cdw2.mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
<            conf[i][j].cdw2.mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
<            conf[i][j].cdw2.mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
<            conf[i][j].cdw2.lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
< d3764 1
< d3767 1
< d3770 1
< d3772 2
< a3773 1
<            bus[i][j].br[3].h
< d4174 4
< a4177 1
<          int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< d4240 3
< a4242 1
<   if (ea0bs & 1) { /* feedback-loop */
< d4253 15
< d4297 4
< a4300 1
<          int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
< d4363 3
< a4365 1
<   if (ea1bs & 1) { /* feedback-loop */
< d4376 15
< d4492 9
< a4500 7
<          int ea0op,  /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
<          int mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
<          int mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
<          int mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
<          int mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
<          int mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
< 	 int lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
< d4506 1
< a4506 1
<   int ea0store = (ea0op&0x10);
< d4509 1
< a4509 1
<   if (mwsa==0) {
< d4520 1
< a4520 1
<   if (ea0store || mwsa==0) {
< d4535 2
< a4536 2
<   if ((ea0store || mwsa==0) && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
<   else                               { col=0; /*black*/ thi=1; }
< d4538 2
< a4539 2
<   if ((ea0store || mwsa==0) && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                               { col=0; /*black*/ thi=1; }
< d4541 2
< a4542 2
<   if ((ea0store || mwsa==0) && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
<   else                               { col=0; /*black*/ thi=1; }
< d4546 1
< a4546 1
<   if (ea0store || mwsa==0) {
< d4561 2
< a4562 2
<   if ((ea0store || mwsa==0) && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
<   else                               { col=0; /*black*/ thi=1; }
< d4564 2
< a4565 2
<   if ((ea0store || mwsa==0) && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                               { col=0; /*black*/ thi=1; }
< d4567 2
< a4568 2
<   if ((ea0store || mwsa==0) && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
<   else                               { col=0; /*black*/ thi=1; }
< d4572 1
< a4572 1
<   if (ea0store || mwsa==0) {
< d4587 2
< a4588 2
<   if ((ea0store || mwsa==0) && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
<   else                               { col=0; /*black*/ thi=1; }
< d4590 2
< a4591 2
<   if ((ea0store || mwsa==0) && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                               { col=0; /*black*/ thi=1; }
< d4593 2
< a4594 2
<   if ((ea0store || mwsa==0) && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
<   else                               { col=0; /*black*/ thi=1; }
< d4598 1
< a4598 1
<   if (ea0store || mwsa==0) {
< d4613 2
< a4614 2
<   if ((ea0store || mwsa==0) && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
<   else                               { col=0; /*black*/ thi=1; }
< d4616 2
< a4617 2
<   if ((ea0store || mwsa==0) && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
<   else                               { col=0; /*black*/ thi=1; }
< d4619 2
< a4620 2
<   if ((ea0store || mwsa==0) && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
<   else                               { col=0; /*black*/ thi=1; }
< d4625 1
< a4625 1
<     draw_text(lmb_x+430, lmb_y+15, "M0", 1, 0);
< d4628 1
< a4628 1
<     draw_text(lmb_x+430, lmb_y+15, "M1", 1, 0);
< d4631 1
< a4631 1
<     draw_text(lmb_x+430, lmb_y+15, "M2", 1, 0);
< d4634 1
< a4634 1
<     draw_text(lmb_x+430, lmb_y+15, "M3", 1, 0);
< d4637 1
< d4649 1
< d4652 1
< d4655 1
< d4657 2
< a4658 1
<          int br3h
< d4744 5
< a4748 1
<     draw_text(bri_x+365,   bri_y+14, id[br0h].name, 1, 0);
< d4824 5
< a4828 1
<     draw_text(bri_x+245,   bri_y+14, id[br1h].name, 1, 0);
< d4888 5
< a4892 1
<     draw_text(bri_x+125,   bri_y+14, id[br2h].name, 1, 0);
< d4947 5
< a4951 1
<     draw_text(bri_x+5,     bri_y+14, id[br3h].name, 1, 0);
< @
< 
< 
< 1.87
< log
< @*** empty log message ***
< @
< text
< @d2 1
< a2 1
< static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.86 2021/06/18 03:04:05 nakashim Exp nakashim $";
< a2425 1
<   fprintf(ofile, "\temax6.lastdist = 0;\n");
< d2559 1
diff -r /home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.h,v ./RCS/emax6.h,v
1c1
< head	1.142;
---
> head	1.141;
5c5
< 	nakashim:1.142; strict;
---
> 	nakashim:1.141; strict;
9,13d8
< 1.142
< date	2021.09.21.07.42.15;	author nakashim;	state Exp;
< branches;
< next	1.141;
< 
724c719
< 1.142
---
> 1.141
750,755c745,749
< void /*__attribute__((always_inline))*/ cex(Uint, Ull*,    Ull, Ull, Ull, Ull, Ushort);
< void /*__attribute__((always_inline))*/ ex4(Uint, Ull*,    Ull*, Uint, Ull*, Uint, Ull*, Uint, Uint, Ull*, Uint, Ull*);
< int  /*__attribute__((always_inline))*/ exe(Uint, Ull*,    Ull, Uint, Ull, Uint, Ull, Uint, Uint, Ull, Uint, Ull);
< void /*__attribute__((always_inline))*/ mex(Uint, Uchar**, Uchar*, Ull, Ull, Ull);
< void /*__attribute__((always_inline))*/ mo4(Uint, Ull,     Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
< void /*__attribute__((always_inline))*/ mop(Uint, Ull,     Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
---
> void /*__attribute__((always_inline))*/ cex(Uint, Ull*, Ull, Ull, Ull, Ull, Ushort);
> void /*__attribute__((always_inline))*/ ex4(Uint, Ull*, Ull*, Uint, Ull*, Uint, Ull*, Uint, Uint, Ull*, Uint, Ull*);
> int  /*__attribute__((always_inline))*/ exe(Uint, Ull*, Ull, Uint, Ull, Uint, Ull, Uint, Uint, Ull, Uint, Ull);
> void /*__attribute__((always_inline))*/ mo4(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
> void /*__attribute__((always_inline))*/ mop(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
757,759c751,752
< void /*__attribute__((always_inline))*/ eam(Ull*, Ull,     Uchar);
< void /*__attribute__((always_inline))*/ eag(Ull*, Ull,     Ull);
< void /*__attribute__((always_inline))*/ mmp(Uint, Ull,     Ull*, Ull, Ull, Uint, Uint);
---
> void /*__attribute__((always_inline))*/ eag(Ull*, Ull, Ull, Uchar);
> void /*__attribute__((always_inline))*/ mmp(Uint, Ull, Ull*, Ull, Ull, Uint, Uint);
798d790
< #define OP_CFMA         0x0a
853,856d844
< #define OP_CMPA_LE      1
< #define OP_CMPA_GE      2
< #define OP_ALWAYS       3
< 
907,910c895,897
< #define ITYPE_MEX   6
< #define ITYPE_MO4   7
< #define ITYPE_MOP   8
<     char type      ; /* type 0:none, 1:WHILE, 2:FOR, 3:CEX, 4:EX4, 5:EXE, 6:MEX, 7:MO4, 8:MOP */
---
> #define ITYPE_MO4   6
> #define ITYPE_MOP   7
>     char type      ; /* type 0:none, 1:WHILE, 2:FOR, 3:CEX, 4:EX4, 5:EXE, 6:MO4, 7:MOP */
963,983d949
<   struct mex {
<     char op        ; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<     Ull  init   : 1; /* mex(sparse matrix) 0:none, 1:INIT0? */
<     char src1v     ; /* id.type */
<     int  src1h     ; /* hash val */
<     char src1s     ; /* suffix for bdr[][][s] */
<     char src2v     ; /* id.type */
<     int  src2h     ; /* hash val */
<     char src2s     ; /* suffix for bdr[][][s] */
<     char distv     ; /* id.type */
<     int  disth     ; /* hash val */
<     char src3v     ; /* id.type */
<     int  src3h     ; /* hash val */
<     char src3s     ; /* suffix for var[s], bdr[][][s] */
<     char src4v     ; /* id.type */
<     int  src4h     ; /* hash val */
<     char src4s     ; /* suffix for var[s], bdr[][][s] */
<     char mexdv     ; /* id.type */
<     int  mexdh     ; /* hash val */
<     char mexds     ; /* suffix for var[s] */
<   } imex;
1010c976
<     char offsm     ; /* 0:B0, 1:B1, ... 7:B7, 8:H0, 9:H1, 10:H2, 11:H3, 12:W0, 13:W1, 14:D0, 15:-- */
---
>     char offsm     ; /* 0:B0, 1:B1, ... 7:B7, 8:H0, 9:H1, 10:H2, 11:H3, 12:W0, 13:W1, 14:--, 15:D0 */
1060,1061d1025
<   struct mex dmex0; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<   struct mex dmex1; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
1135,1142c1099
<     /* sparse matrix */
<     Ull  mex0op :  2; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<     Ull  mex0init: 1; /* mex(sparse matrix) 0:none, 1:INIT0? */
<     Ull  mex0dist: 3; /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<     Ull  mex1op :  2; /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
<     Ull  mex1init: 1; /* mex(sparse matrix) 0:none, 1:INIT0? */
<     Ull  mex1dist: 3; /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
<     Ull  dmy00  :  8;
---
>     Ull  dmy00  : 20;
1157c1114
<     Ull  ea1bs  :  2; /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
---
>     Ull  ea1bs  :  2; /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
1296,1332d1252
< @
< 
< 
< 1.141
< log
< @*** empty log message ***
< @
< text
< @d22 6
< a27 5
< void /*__attribute__((always_inline))*/ cex(Uint, Ull*, Ull, Ull, Ull, Ull, Ushort);
< void /*__attribute__((always_inline))*/ ex4(Uint, Ull*, Ull*, Uint, Ull*, Uint, Ull*, Uint, Uint, Ull*, Uint, Ull*);
< int  /*__attribute__((always_inline))*/ exe(Uint, Ull*, Ull, Uint, Ull, Uint, Ull, Uint, Uint, Ull, Uint, Ull);
< void /*__attribute__((always_inline))*/ mo4(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
< void /*__attribute__((always_inline))*/ mop(Uint, Ull, Ull*, Ull, Ull, Uchar, Ull, Uint, Uint, Uchar, Ull, Uint);
< d29 3
< a31 2
< void /*__attribute__((always_inline))*/ eag(Ull*, Ull, Ull, Uchar);
< void /*__attribute__((always_inline))*/ mmp(Uint, Ull, Ull*, Ull, Ull, Uint, Uint);
< d70 1
< d125 4
< d179 4
< a182 3
< #define ITYPE_MO4   6
< #define ITYPE_MOP   7
<     char type      ; /* type 0:none, 1:WHILE, 2:FOR, 3:CEX, 4:EX4, 5:EXE, 6:MO4, 7:MOP */
< d235 21
< d282 1
< a282 1
<     char offsm     ; /* 0:B0, 1:B1, ... 7:B7, 8:H0, 9:H1, 10:H2, 11:H3, 12:W0, 13:W1, 14:--, 15:D0 */
< d332 2
< d407 8
< a414 1
<     Ull  dmy00  : 20;
< d429 1
< a429 1
<     Ull  ea1bs  :  2; /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
diff -r /home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6lib.c,v ./RCS/emax6lib.c,v
1c1
< head	1.155;
---
> head	1.154;
5c5
< 	nakashim:1.155; strict;
---
> 	nakashim:1.154; strict;
9,13d8
< 1.155
< date	2021.09.21.07.42.15;	author nakashim;	state Exp;
< branches;
< next	1.154;
< 
789c784
< 1.155
---
> 1.154
1657d1651
<   case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
1945,1959d1938
<   case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
<     f1.i = (Uint)(r1);
<     f2.i = (Uint)(r2>>32);
<     f3.i = (Uint)(r3>>32);
<     if (f2.i != -1 && f2.i == f3.i) {
<       f2.i = (Uint)(r2);
<       f3.i = (Uint)(r3);
<       f0.f = f1.f + (f2.f * f3.f);
<     }
<     else {
<       f0.f = f1.f;
<     }
<     t0 = f0.i;
<     ex1_outd = t0;
<     break;
2376,2401c2355
< mex(Uint op_mx, Uchar **d, Uchar *base, Ull ofs, Ull s2, Ull s1)
< {
<   Uint ss2 = s2>>32;
<   Uint ss1 = s1>>32;
< 
<   switch (op_mx) {
<   case OP_NOP:
<     *d = base;
<     break;
<   case OP_CMPA_LE:
<     *d = base + ((ss1!=0xffffffff && ss2<=ss1) ? ofs:0); /* sparse matrix */
<     break;
<   case OP_CMPA_GE:
<     *d = base + ((ss2!=0xffffffff && ss2>=ss1) ? ofs:0); /* sparse matrix */
<     break;
<   case OP_ALWAYS: /* base++ 対応 */
<     *d = base + ofs;
<     break;
<   default:
<     printf("emax6lib: mex: undefined op_mx=%d\n", op_mx);
<     break;
<   }  
< }
< 
< void /*__attribute__((always_inline))*/
< eam(Ull *ofs, Ull offset, Uchar msk)
---
> eag(Ull *adr, Ull base, Ull offset, Uchar msk)
2453,2459c2407
<   *ofs = offset;
< }
< 
< void /*__attribute__((always_inline))*/
< eag(Ull *adr, Ull base, Ull ofs)
< {
<   *adr = base + ofs;
---
>   *adr = base + offset;
2465c2413
<   Ull adr, ofs;
---
>   Ull adr;
2467,2468c2415
<   eam(&ofs, offset, msk);
<   eag(&adr, base, ofs);
---
>   eag(&adr, base, offset, msk);
2475c2422
<   Ull adr, ofs;
---
>   Ull adr;
2477,2478c2424
<   eam(&ofs, offset, msk);
<   eag(&adr, base, ofs);
---
>   eag(&adr, base, offset, msk);
2617,2644d2562
< @
< 
< 
< 1.154
< log
< @*** empty log message ***
< @
< text
< @d864 1
< d1152 15
< d1583 26
< a1608 1
< eag(Ull *adr, Ull base, Ull offset, Uchar msk)
< d1660 7
< a1666 1
<   *adr = base + offset;
< d1672 1
< a1672 1
<   Ull adr;
< d1674 2
< a1675 1
<   eag(&adr, base, offset, msk);
< d1682 1
< a1682 1
<   Ull adr;
< d1684 2
< a1685 1
<   eag(&adr, base, offset, msk);
Only in ./: yacc_lex_util.c
Only in ./: yacc_lex_util.h
Only in ./: yacc_lex_util.o
Only in ./: y.output
Only in ./: y.tab.c
Only in ./: y.tab.h
Only in ./: y.tab.o
