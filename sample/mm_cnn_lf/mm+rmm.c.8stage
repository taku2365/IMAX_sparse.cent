
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/sample/mm_cnn_lf/RCS/mm.c,v 1.4 2018/02/04 10:28:53 nakashim Exp nakashim $";

/*                          Copyright (C) 2013- by NAIST */
/*                           Primary writer: Y.Nakashima */
/*                                  nakashim@is.naist.jp */

#ifndef UTYPEDEF
#define UTYPEDEF
typedef unsigned char      Uchar;
typedef unsigned short     Ushort;
typedef unsigned int       Uint;
typedef unsigned long long Ull;
typedef long long int      Sll;
#if __AARCH64EL__ == 1
typedef long double Dll;
#else
typedef struct {Ull u[2];} Dll;
#endif
#endif

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <math.h>
#ifndef ARMSIML
#include <unistd.h>
#include <sys/times.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <pthread.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/extensions/Xdbe.h>
#endif

int WD=320, HT=240, BITMAP=320*240, SCRWD=5, SCRHT=5, VECWD=240, VECHT=240, VECSTEP=4;

#if defined(EMAX6)
#include "../../src/conv-c2c/emax6.h"
#include "../../src/conv-c2c/emax6lib.c"
#endif
#if !defined(ARMSIML)
#include "./xdisp.c"
#endif

Uchar* membase;

sysinit(memsize, alignment) Uint memsize, alignment;
{
#if defined(ARMZYNQ) && defined(EMAX5)
  if (emax5_open() == NULL)
    exit(1);
  membase = emax_info.hpp_mmap;
  {int i; for (i=0; i<(memsize+sizeof(Dll)-1)/sizeof(Dll); i++) *((Dll*)membase+i)=0;}
#elif defined(ARMZYNQ) && defined(EMAX6)
  if (emax6_open() == NULL)
    exit(1);
  membase = emax_info.ddr_mmap;
  {int i; for (i=0; i<(memsize+sizeof(Dll)-1)/sizeof(Dll); i++) *((Dll*)membase+i)=0;}
#else
  membase = (void*)malloc(memsize+alignment);
  if ((int)membase & (alignment-1))
    membase = (void*)(((int)membase & ~(alignment-1))+alignment);
#endif

#if !defined(ARMZYNQ) && defined(EMAX5)
  emax_info.hpp_phys = membase;
  emax_info.hpp_mmap = emax_info.hpp_phys;
  emax_info.acp_phys = ACP_BASE2_PHYS; /* defined in emax5lib.h >= ALOCLIMIT */
  emax_info.acp_mmap = emax_info.acp_phys;
#endif
#if defined(EMAX5)
  acp_conf = emax_info.acp_mmap; /* 8KB * 256sets */
  acp_lmmi = emax_info.acp_mmap + 0x200000;
  acp_regv = emax_info.acp_mmap + 0x304000;
#endif

#if !defined(ARMZYNQ) && defined(EMAX6)
  emax_info.dma_phys = DMA_BASE2_PHYS; /* defined in emax6lib.h */
  emax_info.dma_mmap = emax_info.dma_phys;
  emax_info.reg_phys = REG_BASE2_PHYS; /* defined in emax6lib.h */
  emax_info.reg_mmap = emax_info.reg_phys;
  emax_info.lmm_phys = LMM_BASE2_PHYS;
  emax_info.lmm_mmap = emax_info.lmm_phys;
  emax_info.ddr_phys = membase;
  emax_info.ddr_mmap = emax_info.ddr_phys;
#endif
#if (defined(ARMSIML) || defined(ARMZYNQ)) && defined(EMAX6)
  emax6.dma_ctrl  = emax_info.dma_mmap;
  emax6.reg_ctrl  = emax_info.reg_mmap;
  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].cmd = CMD_RESET;  // ★★★ RESET
#if defined(ARMZYNQ)
  usleep(1);
#endif
  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].adtr = emax_info.ddr_mmap - emax_info.lmm_phys;
  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp = 0LL;
#endif
}

/* LMM:16KB, RMM:64KB: M/NCHIP=124 M/NCHIP/RMGRP=31 */
/* A A   B B B B B B   C C C C C C */
/* A A   B B B B B B   C C C C C C */
/* A A                 C C C C C C */
/* A A                 C C C C C C */
/* L=2, M1=4, M2=6     L<M1,M2     */

#define L  480LL
#define M1 480LL
#define M2 480LL
#define RMGRP 16
/*#define NCHIP 4*/
#define NCHIP 1
#define W  4LL
#define H  4
Uint *A;  /*[M1][L];*/
Uint *B;  /*[L][M2];*/
Uint *C0; /*[M1][M2];*/
Uint *C1; /*[M1][M2];*/
int row, col, n;
int top, blk;
int w, h;
int count0, count1, count2;

#define CSIMWD 320
#define CSIMHT 240
#define CSIMBM (CSIMWD*CSIMHT)
Uint Z[CSIMBM];

#define MAXINT (~(1<<(sizeof(int)*8-1)))
#define adif(a,b) (((a)>(b))?(a)-(b):(b)-(a))
#define dif(a,b)  (adif((((a)>>24)&255), (((b)>>24)&255))\
                  +adif((((a)>>16)&255), (((b)>>16)&255))\
                  +adif((((a)>> 8)&255), (((b)>> 8)&255)))
#define abs(a) (((a)<0)?-(a):(a))

main()
{
  sysinit((Uint)(M1*L*sizeof(Uint)
                +L*M2*sizeof(Uint)
                +M1*M2*sizeof(Uint)
                +M1*M2*sizeof(Uint)),32);
  printf("membase: %08.8x\n", (Uint)membase);
  A  = (Uint*)membase;
  B  = (Uint*)((Uchar*)A  + M1*L*sizeof(Uint));
  C0 = (Uint*)((Uchar*)B  + L*M2*sizeof(Uint));
  C1 = (Uint*)((Uchar*)C0 + M1*M2*sizeof(Uint));
  printf("A : %08.8x\n", A);
  printf("B : %08.8x\n", B);
  printf("C0: %08.8x\n", C0);
  printf("C1: %08.8x\n", C1);

  for (row=0; row<M1; row++) {
    for (col=0; col<L; col++)
      *(float*)&A[row*L+col] = row%120+1;
  }
  for (row=0; row<L; row++) {
    for (col=0; col<M2; col++)
      *(float*)&B[row*M2+col] = col%120+1;
  }

#if !defined(ARMSIML)
  x11_open(0);
#endif

  reset_nanosec();
  orig();
  get_nanosec(0);
  show_nanosec();

  reset_nanosec();
  imax();
  get_nanosec(0);
  show_nanosec();

#ifdef ARMSIML
  copy_Z(0, C1); _copyX(0, Z);
  copy_Z(1, C1); _copyX(1, Z);
  copy_Z(4, C1); _copyX(4, Z);
  copy_Z(5, C1); _copyX(5, Z);
  copy_Z(8, C1); _copyX(8, Z);
  copy_Z(9, C1); _copyX(9, Z);
  _updateX();
#endif
#if !defined(ARMSIML)
  copy_Z(0, C1); BGR_to_X(0, Z);
  copy_Z(1, C1); BGR_to_X(1, Z);
  copy_Z(4, C1); BGR_to_X(5, Z);
  copy_Z(5, C1); BGR_to_X(6, Z);
  copy_Z(8, C1); BGR_to_X(10,Z);
  copy_Z(9, C1); BGR_to_X(11,Z);
  x11_update();
#endif

  printf("Num of MULT: orig=%d imax=%d\n", count0, count1);

  for (row=0; row<M1; row++) {
    for (col=0; col<M2; col++) {
      if (C0[row*M2+col] != C1[row*M2+col]) {
        count2++;
        printf("C0[%d][%d]=%f C1[%d][%d]=%f\n", row, col, (double)*(float*)&C0[row*M2+col],
                                                row, col, (double)*(float*)&C1[row*M2+col]);
      }
    }
  }
  if (count2)
    printf("Num of diffs: %d\n", count2);
  else
    printf("Results are equal\n");

  show_nanosec();

#if !defined(ARMSIML)
  printf("==== Normal end. Type any in ImageWin ====\n");
  while (!x11_checkevent());
#endif
}

copy_Z(id, from)
     int id; /* 0 .. 11 */
     unsigned int *from;
{
  int i, j;
  volatile unsigned int *to = Z;
  unsigned int *offs;

  switch (id) {
  case 0:  offs = from;               break;
  case 1:  offs = from + WD;          break;
  case 2:  offs = from + WD*2;        break;
  case 3:  offs = from + WD*3;        break;
  case 4:  offs = from + M2*HT;        break;
  case 5:  offs = from + M2*HT+WD;     break;
  case 6:  offs = from + M2*HT+WD*2;   break;
  case 7:  offs = from + M2*HT+WD*3;   break;
  case 8:  offs = from + M2*HT*2;      break;
  case 9:  offs = from + M2*HT*2+WD;   break;
  case 10: offs = from + M2*HT*2+WD*2; break;
  case 11: offs = from + M2*HT*2+WD*3; break;
  case 12: offs = from + M2*HT*3;      break;
  case 13: offs = from + M2*HT*3+WD;   break;
  case 14: offs = from + M2*HT*3+WD*2; break;
  case 15: offs = from + M2*HT*3+WD*3; break;
  }
  for (i=0; i<HT; i++, offs+=M2) {
    if (offs<from+M1*M2) {
      for (j=0; j<WD; j++) {
	if (j+(id%4)*WD<M2) *to++ = (*(offs+j))>>0;
	else                *to++ = 0;
      }
    }
    else {
      for (j=0; j<WD; j++)
	*to++ = 0;
    }
  }
}

orig() {
  printf("<<<ORIG>>>\n");
  for (row=0; row<M1; row++) {
    for (col=0; col<M2; col++) {
      for (n=0; n<L; n++) {
        if (n==0) *(float*)&C0[row*M2+col]  = *(float*)&A[row*L+n] * *(float*)&B[n*M2+col];
        else      *(float*)&C0[row*M2+col] += *(float*)&A[row*L+n] * *(float*)&B[n*M2+col];
        count0++;
        /*printf("[%d %d %d]", row, col, n);*/
      }
      /*printf("\n");*/
    }
  }
}

#if 0
imax() {
  Ull CHIP;
  Ull rofs;
  printf("<<<IMAX>>>\n");
  for (top=0; top<M1/NCHIP; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (blk=0; blk<L; blk+=H) { /* 3重ループ目 (Cが確定するまでのDMA入れ換えはR/Wを伴うためオーバヘッドになる. Bのbroadcast回数を増やす方が結果的に高速) */
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
          /*【3重ループ制御方法】                                                                                                                                                              */
          /*    loop0-reg 4           4           4           4           4           4           4           4           4           4           4           4           4                    */
          /*                 3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  3  2  1  0  - (stop1=1)       */
          /*    loop1-reg 4                                               4                                               4                                               4                    */
          /*                          3           2           1           0           3           2           1           0           3           2           1           0                    */
          /*    loop2-reg 3                                                                                                                                               3                    */
          /*                                                              2                                               1                                               0                    */
          /*                                                                                                                                                   【★Ａ★】 ↑arbrk=1(停止)      */
          /*                ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex --------- */
          /*        loop0    0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3  - (stop1=1)       */
          /*        loop1    0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3  0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3  0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3                    */
          /*        loop2    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2                    */

          /*【★Ａ★】部分の拡大              0         1         2         3      |  0         1         2         3      |  0         1         2         3      |  0                        */
          /*                 unit1 clk  ___/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____                  */
          /*                   stage1d  ----< loop0=2 X loop1=1 X loop2=1 X ======= X loop0=1 X loop1=1 X loop2=1 X ======= X loop0=4★-----------------------------X loop0=3                  */
          /*                                                                                                                  init0=1★                            |                           */
          /*                   stage2d  --------------< 0nzero  X nop     X nop     X ======= X 0zero★ X 1zero★ X 2zero★ X ======= >--------------------------------------                  */
          /*                                                                                                ↑        ↑                                           |                           */
          /*                                                                                           前cycle:zeroの場合decr                                      |                           */
          /*                   stage3d  ------------------------< loop0=1 X loop1=1 X loop2=1 X ======= X loop0=0 X loop1=0 X lop2=0★X ======= X loop0=3 >------------------                  */
          /*                                                                                                            ↑stage1dに戻る                            |                           */
          /*                                                                                                            │この時0ならstage1dにinit0=1を通知.stage1dに初期値をBRからセット      */
          /*                                                                                                            │init0=1は下方(BR)に伝搬                  |                           */
          /*                   stage4d  ----------------------------------< loop0=1 X loop1=1 X loop2=1 X ======= X loop0=0 X lop1=0  X lop2=0★X ======= X loop0=3 >--------       init0=1が  */
          /*                                                                                                                                                init0=1|              │次段unitへ */
          /*                                                                                                                                                       |stop1=1       ↓           */
          /*                                  0         1         2         3      |  0         1         2         3      |  0         1         2         3      |  0        stage1dに初期値 */
          /*                 unit2 clk  ___/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____                  */
          /*                                                                                                          ★OP_WHILEが存在  かつ zeroの場合にarbrk=1セット★                       */
          /*                【3重ループのパターン】                                                       ★col=0から順に調べ nonzeroの場合はarbrk=0に戻す★                                   */
          /*                                     col2=0  col1=0  col0=0                                                                                                                        */
          /*                                       ↓      ↓      ↓     DMA以外のレジスタ値設定を自動化                                                                                      */
          /*                                     arbrk=1 init1=1 init0=1  受信したら初期値再セット                                                                                             */
          /*                                                   0       1                                                                                                                       */
          /*                                                   1       0                                                                                                                       */
          /*                                                   1       1                                                                                                                       */
          /*                                           1       X       X  IMAX終了                                                                                                             */
          /*                                                                                                                                                                                   */
          /*                【2重ループのパターン】      col1=0  col0=0                                                                                                                        */
          /*                                               ↓      ↓     DMA以外のレジスタ値設定を自動化                                                                                      */
          /*                                             arbrk=1 init0=1  受信したら初期値再セット                                                                                             */
          /*                                                   0       1  A先頭はA[0][0]からA[1][0]に変更（480x4B加算）                                                                        */
          /*                                                              B先頭は元に戻す(ofs=-Wx4に戻す:実際にはselfloopを一度解除しBRから入力するだけ)                                       */
          /*                                                              RANGEは60行x480列x4B=115200を加算(lenは無変更)                                                                       */
          /*                                                                exe(OP_ADD, &ofs, ★INIT0, ofs, EXP_H3210, W*4, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);              */
          /*                                                                                            ↑Cの記述はそのまま.IMAXではBRに初期値が残っているので利用                             */
          /*                                                                mop(OP_LDUWR,  1, &BR[1][0][1],  ★(Ull)b000, (Ull)ofs, MSK_D0, ★(Ull)b00, M/2, 0, 0, (Ull)NULL, M/2);            */
          /*                                                                                            ↑Cの記述はそのまま.2重ループの範囲では増分指定不要                                    */
          /*                                                   1       X  IMAX終了                                                                                                             */

          /*【3重ループ参照パターン】                                                                                                                                                          */
          /* a0000 a0001 a0002 a0003 a0004 ... a0059 | a0060 a0061 ... *//* LMM[ 0] b0000 b0001 b0002 b0003 b0004 ... b0059 b0099 ... *//* partial c0000 c0001 c0002 c0003 c0004 ... c0099 ... */
          /* a0100 a0101 a0102 a0103 a0104 ... a0159 | a0160 a0161 ... *//* LMM[ 1] b0100 b0101 b0102 b0103 b0104 ... b0159 b0199 ... *//* partial c0100 c0101 c0102 c0103 c0104 ... c0199 ... */
          /* a0200 a0201 a0202 a0203 a0204 ... a0259 | a0260 a0261 ... *//* LMM[ 2] b0200 b0201 b0202 b0203 b0204 ... b0259 b0299 ... *//* partial c0200 c0201 c0202 c0203 c0204 ... c0299 ... */
          /* a0300 a0301 a0302 a0303 a0304 ... a0359 | a0360 a0361 ... *//* LMM[ 3] b0300 b0301 b0302 b0303 b0304 ... b0359 b0399 ... *//* partial c0300 c0301 c0302 c0303 c0304 ... c0399 ... */
          /*                                                           *//* LMM[59] b5900 b5901 b5902 b5903 b5904 ... b5959 b5999 ... *//*                                                     */
          /*                                                           *//* --------------------------------------------------------- *//*                                                     */
          /* a9900 a9901 a9902 a9903 a9904 ... a9959 | a9960 a9961 ... *//* LMM[99] b9900 b9901 b9902 b9903 b9904 ... b9959 b9999 ... *//* partial c9900 c9901 c9902 c9903 c9904 ... c9999 ... */

          /*【3重ループ実行手順】                                                                                                                                                              */
          /* ================================== 3重ループ開始 ================================================================================================================================ */
          /*   LMM00: A[0:7][0:479] (必要なのはa000000,001000,...007000) 480x8x4B=16KB | B[00][0:479] 480x4B=2KB                                                                               */
          /*                                   a000060,001060,...007060                |                                                                                                       */
          /*                                   a000420,001420,...007420                |                                                                                                       */
          /*   LMM01: A[0:7][0:479] (必要なのはa000001,001001,...007001)               | B[01][0:479] 480x4B=2KB                                                                               */
          /*                                   a000061,001061,...007061                |                                                                                                       */
          /*                                   a000421,001421,...007421                |                                                                                                       */
          /*   LMM59: A[0:7][0:479] (必要なのはa000059,001059,...007059) 8要素         | B[59][0:479] 480x4B=2KB                                                                               */
          /*                                   a000119,001119,...007119  8要素         |                                                                                                       */
          /*                                   a000479,001479,...007479  8要素x8blk分  |                                                                                                       */
          /*   LMM60: ---------------------------------------------------------------------------------------- C[0:7][0:479] 480x8x4B=16KB  Cの途中結果をR/Wで入れ換えるのは損                 */
          /*                                                                                                   multi-chipに対するR/Wがシリアライズされるし,LMMのREADは遅いので回数を減らすべき */
          /* ★RANGE設定,A[0:7][0:479]を一度に供給                                                                                           ★RANGE設定,C[0:7][*]初期化書き込み               */
          /* ================================== 3重ループ先頭開始 BLK=0======================================================================================================================= */
          /*                                                                        ★BのREGV+RANGEを設定,次のB[  0: 59]を1回のburstで供給(MC-broadcast)                                       */
          /* ---------------------------------- 2重ループIMAX開始 --3重loopのblk-iteration-- 1回目 (blk=0)                            *//*                                                     */
          /* A[0][  0: 59]->LMMを再利用                                *//*   row= 0: B[  0][*]:480*4B=2KB /LMM(1/2) b00=B+(blk+ 0)*M *//*  row=0: C[0][*]:480*4B=2KB / LMM┐                  */
          /* A[1][  0: 59]->LMMを再利用                                *//*   row= 1: B[  1][*]:480*4B=2KB /LMM(1/2) b01=B+(blk+ 1)*M *//*  row=1: C[1][*]:480*4B=2KB / LMM│合計16KBは実際は  */
          /* A[7][  0: 59]->LMMを再利用                                *//*   row=59: B[ 59][*]:480*4B=2KB /LMM(1/2) b59=B+(blk+59)*M *//*  row=7: C[7][*]:480*4B=2KB / LMM┘1LMMに収容可能    */
          /* ---------------------------------- IMAX動作一旦終了 ----------------------------------------------------------------------------------------------------------------------------- */
          /*                                                                        ★BのREGV+RANGEを設定,次のB[ 60:119]を1回のburstで供給(MC-broadcast)                                       */
          /* ---------------------------------- 2重ループIMAX開始 --3重loopのblk-iteration-- 2回目 (blk=1)   B[0]とB[60]の距離は480*60*4B(128KB),LMM共存無理                                   */
          /* A[0][ 60:119]->LMMを再利用                                *//*   row= 0: B[ 60][*]:480*4B=2KB /LMM(1/2) b00+=(H-1)*M*4B  *//*  row=0: C[0][*]:480*4B=2KB / LMM (update)           */
          /* A[1][ 60:119]->LMMを再利用                                *//*   row= 1: B[ 61][*]:480*4B=2KB /LMM(1/2) b01+=(H-1)*M*4B  *//*  row=1: C[1][*]:480*4B=2KB / LMM (update)           */
          /* A[7][ 60:119]->LMMを再利用                                *//*   row=59: B[119][*]:480*4B=2KB /LMM(1/2) b59+=(H-1)*M*4B  *//*  row=7: C[7][*]:480*4B=2KB / LMM (update)           */
          /* ---------------------------------- IMAX動作一旦終了 ----------------------------------------------------------------------------------------------------------------------------- */
          /*                                                                        ★BのREGV+RANGEを設定,次のB[420:479]を1回のburstで供給(MC-broadcast)                                       */
          /* ---------------------------------- 2重ループIMAX開始 --3重loopのblk-iteration-- 8回目 (blk=7)                            *//*                                                     */
          /* A[0][420:479]->LMMを再利用                                *//*   row= 0: B[420][*]:480*4B=2KB /LMM(1/2) b00+=(H-1)*M*4B  *//*  row=0: C[0][*]:480*4B=2KB / LMM (update)           */
          /* A[1][420:479]->LMMを再利用                                *//*   row= 1: B[421][*]:480*4B=2KB /LMM(1/2) b01+=(H-1)*M*4B  *//*  row=1: C[1][*]:480*4B=2KB / LMM (update)           */
          /* A[7][420:479]->LMMを再利用                                *//*   row=59: B[479][*]:480*4B=2KB /LMM(1/2) b59+=(H-1)*M*4B  *//*  row=7: C[7][*]:480*4B=2KB / LMM (update)           */
          /* ---------------------------------- IMAX動作一旦終了 ----------------------------------------------------------------------------------------------------------------------------- */
          /* ================================== 3重ループ全体終了 ============================================================================================================================ */
          /* ★A[8:15][0:479]を一度に供給                                                                                                    ★RANGE設定,C[0:7][*]READ+C[8:15][*]WRITE         */
          /* ================================== 3重ループ先頭開始 BLK=0======================================================================================================================= */
          /*                                                                        ★BのREGV+RANGEを設定,次のB[  0: 59]を1回のburstで供給(MC-broadcast)                                       */
          /* ---------------------------------- 2重ループIMAX開始 --3重loopのblk-iteration-- 1回目 (blk=0)                            *//*                                                     */
          /* A[ 8][  0: 59]->LMMを再利用                               *//*   row= 0: B[  0][*]:480*4B=2KB /LMM(1/2) b00=B+(blk+ 0)*M *//*  row=0: C[ 8][*]:480*4B=2KB / LMM┐                 */
          /* A[ 9][  0: 59]->LMMを再利用                               *//*   row= 1: B[  1][*]:480*4B=2KB /LMM(1/2) b01=B+(blk+ 1)*M *//*  row=1: C[ 9][*]:480*4B=2KB / LMM│合計16KBは実際は */
          /* A[15][  0: 59]->LMMを再利用                               *//*   row=59: B[ 59][*]:480*4B=2KB /LMM(1/2) b59=B+(blk+59)*M *//*  row=7: C[15][*]:480*4B=2KB / LMM┘1LMMに収容可能   */

    /*1*/ for (col=0; col<M2; col+=W) { /* one-horizontal-line is calculated by EMAX-while(loop--) */
                                        /* C0xの部分和を生成（1行分）1chip分の総量はMword*M/#chip  */
                                        /*                          M=504の場合は64Kword(256KB)    */
                                        /*      さらにchip内でも行を分割すればcsimLMM(128KB)に入る */
            for (w=0; w<W; w++) {   /* horizontal (parallel) execution */
              for (h=0; h<H; h++) { /* vertical (pipelined) execution */
                if (blk == 0 && h == 0)
                  *(float*)&C1[(CHIP*M1/NCHIP+top+rofs)*M2+col+w]  = *(float*)&A[(CHIP*M1/NCHIP+top+rofs)*L+blk+h]**(float*)&B[(blk+h)*M2+col+w];
                else
                  *(float*)&C1[(CHIP*M1/NCHIP+top+rofs)*M2+col+w] += *(float*)&A[(CHIP*M1/NCHIP+top+rofs)*L+blk+h]**(float*)&B[(blk+h)*M2+col+w];
                count1++;
                /*printf("[%d %d %d %d %d %d %d]", CHIP, top, rofs, blk, col, w, h);*/
              }
            }
            /*printf("\n");*/
          }
        }
      }
    }
  }
}

#else

imax() {
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  Ull  cofs, rofs, oofs;
  /*  ┌─────┐convolutionの場合                                                  */
  /*  │┌────┴┐Bが複数と考える                                                  */
  /*  ││┌────┴┐┌─────┐┐        ┌─────┐┐                       */
  /*  │││b         ││a a a a a ││RMGRP   │o o o o o ││RMGRP                  */
  /*  │││b         ┤│          │┤/CHIP   │          │┤/CHIP                  */
  /*  │││b   B0   b││ A(weight)││        │   out    ││ mmの場合は行で分割    */
  /*  └││b        l┤│          │┤        │          │┤ cnnの場合はoutで分割  */
  /*    └│b        k││blk       ││        │blk       ││                       */
  /*      └─────┘└─┴─┴─┘┘        └─┴─┴─┘┘                       */
  printf("<<<IMAX>>>\n");
  for (top=0; top<M1/NCHIP; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (blk=0; blk<L; blk+=H) { /* 3重ループ展開の外側対象 */
      typedef struct {Uint i[4]} Ui4;
      Ui4  *b00 = B+(blk+ 0)*M2, *b000 = b00, *b001 = (Uint*)b00+1, *b002 = (Uint*)b00+2, *b003 = (Uint*)b00+3;
      Ui4  *b01 = B+(blk+ 1)*M2, *b010 = b01, *b011 = (Uint*)b01+1, *b012 = (Uint*)b01+2, *b013 = (Uint*)b01+3;
      Ui4  *b02 = B+(blk+ 2)*M2, *b020 = b02, *b021 = (Uint*)b02+1, *b022 = (Uint*)b02+2, *b023 = (Uint*)b02+3;
      Ui4  *b03 = B+(blk+ 3)*M2, *b030 = b03, *b031 = (Uint*)b03+1, *b032 = (Uint*)b03+2, *b033 = (Uint*)b03+3;
      Ui4  *b04 = B+(blk+ 4)*M2, *b040 = b04, *b041 = (Uint*)b04+1, *b042 = (Uint*)b04+2, *b043 = (Uint*)b04+3;
      Ui4  *b05 = B+(blk+ 5)*M2, *b050 = b05, *b051 = (Uint*)b05+1, *b052 = (Uint*)b05+2, *b053 = (Uint*)b05+3;
      Ui4  *b06 = B+(blk+ 6)*M2, *b060 = b06, *b061 = (Uint*)b06+1, *b062 = (Uint*)b06+2, *b063 = (Uint*)b06+3;
      Ui4  *b07 = B+(blk+ 7)*M2, *b070 = b07, *b071 = (Uint*)b07+1, *b072 = (Uint*)b07+2, *b073 = (Uint*)b07+3;
      Ui4  *b08 = B+(blk+ 8)*M2, *b080 = b08, *b081 = (Uint*)b08+1, *b082 = (Uint*)b08+2, *b083 = (Uint*)b08+3;
      Ui4  *b09 = B+(blk+ 9)*M2, *b090 = b09, *b091 = (Uint*)b09+1, *b092 = (Uint*)b09+2, *b093 = (Uint*)b09+3;
      Ui4  *b10 = B+(blk+10)*M2, *b100 = b10, *b101 = (Uint*)b10+1, *b102 = (Uint*)b10+2, *b103 = (Uint*)b10+3;
      Ui4  *b11 = B+(blk+11)*M2, *b110 = b11, *b111 = (Uint*)b11+1, *b112 = (Uint*)b11+2, *b113 = (Uint*)b11+3;
      Ui4  *b12 = B+(blk+12)*M2, *b120 = b12, *b121 = (Uint*)b12+1, *b122 = (Uint*)b12+2, *b123 = (Uint*)b12+3;
      Ui4  *b13 = B+(blk+13)*M2, *b130 = b13, *b131 = (Uint*)b13+1, *b132 = (Uint*)b13+2, *b133 = (Uint*)b13+3;
      Ui4  *b14 = B+(blk+14)*M2, *b140 = b14, *b141 = (Uint*)b14+1, *b142 = (Uint*)b14+2, *b143 = (Uint*)b14+3;
      Ui4  *b15 = B+(blk+15)*M2, *b150 = b15, *b151 = (Uint*)b15+1, *b152 = (Uint*)b15+2, *b153 = (Uint*)b15+3;
      Ui4  *b16 = B+(blk+16)*M2, *b160 = b16, *b161 = (Uint*)b16+1, *b162 = (Uint*)b16+2, *b163 = (Uint*)b16+3;
      Ui4  *b17 = B+(blk+17)*M2, *b170 = b17, *b171 = (Uint*)b17+1, *b172 = (Uint*)b17+2, *b173 = (Uint*)b17+3;
      Ui4  *b18 = B+(blk+18)*M2, *b180 = b18, *b181 = (Uint*)b18+1, *b182 = (Uint*)b18+2, *b183 = (Uint*)b18+3;
      Ui4  *b19 = B+(blk+19)*M2, *b190 = b19, *b191 = (Uint*)b19+1, *b192 = (Uint*)b19+2, *b193 = (Uint*)b19+3;
      Ui4  *b20 = B+(blk+20)*M2, *b200 = b20, *b201 = (Uint*)b20+1, *b202 = (Uint*)b20+2, *b203 = (Uint*)b20+3;
      Ui4  *b21 = B+(blk+21)*M2, *b210 = b21, *b211 = (Uint*)b21+1, *b212 = (Uint*)b21+2, *b213 = (Uint*)b21+3;
      Ui4  *b22 = B+(blk+22)*M2, *b220 = b22, *b221 = (Uint*)b22+1, *b222 = (Uint*)b22+2, *b223 = (Uint*)b22+3;
      Ui4  *b23 = B+(blk+23)*M2, *b230 = b23, *b231 = (Uint*)b23+1, *b232 = (Uint*)b23+2, *b233 = (Uint*)b23+3;
      Ui4  *b24 = B+(blk+24)*M2, *b240 = b24, *b241 = (Uint*)b24+1, *b242 = (Uint*)b24+2, *b243 = (Uint*)b24+3;
      Ui4  *b25 = B+(blk+25)*M2, *b250 = b25, *b251 = (Uint*)b25+1, *b252 = (Uint*)b25+2, *b253 = (Uint*)b25+3;
      Ui4  *b26 = B+(blk+26)*M2, *b260 = b26, *b261 = (Uint*)b26+1, *b262 = (Uint*)b26+2, *b263 = (Uint*)b26+3;
      Ui4  *b27 = B+(blk+27)*M2, *b270 = b27, *b271 = (Uint*)b27+1, *b272 = (Uint*)b27+2, *b273 = (Uint*)b27+3;
      Ui4  *b28 = B+(blk+28)*M2, *b280 = b28, *b281 = (Uint*)b28+1, *b282 = (Uint*)b28+2, *b283 = (Uint*)b28+3;
      Ui4  *b29 = B+(blk+29)*M2, *b290 = b29, *b291 = (Uint*)b29+1, *b292 = (Uint*)b29+2, *b293 = (Uint*)b29+3;
      Ui4  *b30 = B+(blk+30)*M2, *b300 = b30, *b301 = (Uint*)b30+1, *b302 = (Uint*)b30+2, *b303 = (Uint*)b30+3;
      Ui4  *b31 = B+(blk+31)*M2, *b310 = b31, *b311 = (Uint*)b31+1, *b312 = (Uint*)b31+2, *b313 = (Uint*)b31+3;
      Ui4  *b32 = B+(blk+32)*M2, *b320 = b32, *b321 = (Uint*)b32+1, *b322 = (Uint*)b32+2, *b323 = (Uint*)b32+3;
      Ui4  *b33 = B+(blk+33)*M2, *b330 = b33, *b331 = (Uint*)b33+1, *b332 = (Uint*)b33+2, *b333 = (Uint*)b33+3;
      Ui4  *b34 = B+(blk+34)*M2, *b340 = b34, *b341 = (Uint*)b34+1, *b342 = (Uint*)b34+2, *b343 = (Uint*)b34+3;
      Ui4  *b35 = B+(blk+35)*M2, *b350 = b35, *b351 = (Uint*)b35+1, *b352 = (Uint*)b35+2, *b353 = (Uint*)b35+3;
      Ui4  *b36 = B+(blk+36)*M2, *b360 = b36, *b361 = (Uint*)b36+1, *b362 = (Uint*)b36+2, *b363 = (Uint*)b36+3;
      Ui4  *b37 = B+(blk+37)*M2, *b370 = b37, *b371 = (Uint*)b37+1, *b372 = (Uint*)b37+2, *b373 = (Uint*)b37+3;
      Ui4  *b38 = B+(blk+38)*M2, *b380 = b38, *b381 = (Uint*)b38+1, *b382 = (Uint*)b38+2, *b383 = (Uint*)b38+3;
      Ui4  *b39 = B+(blk+39)*M2, *b390 = b39, *b391 = (Uint*)b39+1, *b392 = (Uint*)b39+2, *b393 = (Uint*)b39+3;
      Ui4  *b40 = B+(blk+40)*M2, *b400 = b40, *b401 = (Uint*)b40+1, *b402 = (Uint*)b40+2, *b403 = (Uint*)b40+3;
      Ui4  *b41 = B+(blk+41)*M2, *b410 = b41, *b411 = (Uint*)b41+1, *b412 = (Uint*)b41+2, *b413 = (Uint*)b41+3;
      Ui4  *b42 = B+(blk+42)*M2, *b420 = b42, *b421 = (Uint*)b42+1, *b422 = (Uint*)b42+2, *b423 = (Uint*)b42+3;
      Ui4  *b43 = B+(blk+43)*M2, *b430 = b43, *b431 = (Uint*)b43+1, *b432 = (Uint*)b43+2, *b433 = (Uint*)b43+3;
      Ui4  *b44 = B+(blk+44)*M2, *b440 = b44, *b441 = (Uint*)b44+1, *b442 = (Uint*)b44+2, *b443 = (Uint*)b44+3;
      Ui4  *b45 = B+(blk+45)*M2, *b450 = b45, *b451 = (Uint*)b45+1, *b452 = (Uint*)b45+2, *b453 = (Uint*)b45+3;
      Ui4  *b46 = B+(blk+46)*M2, *b460 = b46, *b461 = (Uint*)b46+1, *b462 = (Uint*)b46+2, *b463 = (Uint*)b46+3;
      Ui4  *b47 = B+(blk+47)*M2, *b470 = b47, *b471 = (Uint*)b47+1, *b472 = (Uint*)b47+2, *b473 = (Uint*)b47+3;
      Ui4  *b48 = B+(blk+48)*M2, *b480 = b48, *b481 = (Uint*)b48+1, *b482 = (Uint*)b48+2, *b483 = (Uint*)b48+3;
      Ui4  *b49 = B+(blk+49)*M2, *b490 = b49, *b491 = (Uint*)b49+1, *b492 = (Uint*)b49+2, *b493 = (Uint*)b49+3;
      Ui4  *b50 = B+(blk+50)*M2, *b500 = b50, *b501 = (Uint*)b50+1, *b502 = (Uint*)b50+2, *b503 = (Uint*)b50+3;
      Ui4  *b51 = B+(blk+51)*M2, *b510 = b51, *b511 = (Uint*)b51+1, *b512 = (Uint*)b51+2, *b513 = (Uint*)b51+3;
      Ui4  *b52 = B+(blk+52)*M2, *b520 = b52, *b521 = (Uint*)b52+1, *b522 = (Uint*)b52+2, *b523 = (Uint*)b52+3;
      Ui4  *b53 = B+(blk+53)*M2, *b530 = b53, *b531 = (Uint*)b53+1, *b532 = (Uint*)b53+2, *b533 = (Uint*)b53+3;
      Ui4  *b54 = B+(blk+54)*M2, *b540 = b54, *b541 = (Uint*)b54+1, *b542 = (Uint*)b54+2, *b543 = (Uint*)b54+3;
      Ui4  *b55 = B+(blk+55)*M2, *b550 = b55, *b551 = (Uint*)b55+1, *b552 = (Uint*)b55+2, *b553 = (Uint*)b55+3;
      Ui4  *b56 = B+(blk+56)*M2, *b560 = b56, *b561 = (Uint*)b56+1, *b562 = (Uint*)b56+2, *b563 = (Uint*)b56+3;
      Ui4  *b57 = B+(blk+57)*M2, *b570 = b57, *b571 = (Uint*)b57+1, *b572 = (Uint*)b57+2, *b573 = (Uint*)b57+3;
      Ui4  *b58 = B+(blk+58)*M2, *b580 = b58, *b581 = (Uint*)b58+1, *b582 = (Uint*)b58+2, *b583 = (Uint*)b58+3;
      Ui4  *b59 = B+(blk+59)*M2, *b590 = b59, *b591 = (Uint*)b59+1, *b592 = (Uint*)b59+2, *b593 = (Uint*)b59+3;
      Uint *a0[NCHIP];
      Uint *a00[NCHIP], *a01[NCHIP], *a02[NCHIP], *a03[NCHIP], *a04[NCHIP], *a05[NCHIP], *a06[NCHIP], *a07[NCHIP];
      Uint *a08[NCHIP], *a09[NCHIP], *a10[NCHIP], *a11[NCHIP], *a12[NCHIP], *a13[NCHIP], *a14[NCHIP], *a15[NCHIP];
      Uint *a16[NCHIP], *a17[NCHIP], *a18[NCHIP], *a19[NCHIP], *a20[NCHIP], *a21[NCHIP], *a22[NCHIP], *a23[NCHIP];
      Uint *a24[NCHIP], *a25[NCHIP], *a26[NCHIP], *a27[NCHIP], *a28[NCHIP], *a29[NCHIP], *a30[NCHIP], *a31[NCHIP];
      Uint *a32[NCHIP], *a33[NCHIP], *a34[NCHIP], *a35[NCHIP], *a36[NCHIP], *a37[NCHIP], *a38[NCHIP], *a39[NCHIP];
      Uint *a40[NCHIP], *a41[NCHIP], *a42[NCHIP], *a43[NCHIP], *a44[NCHIP], *a45[NCHIP], *a46[NCHIP], *a47[NCHIP];
      Uint *a48[NCHIP], *a49[NCHIP], *a50[NCHIP], *a51[NCHIP], *a52[NCHIP], *a53[NCHIP], *a54[NCHIP], *a55[NCHIP];
      Uint *a56[NCHIP], *a57[NCHIP], *a58[NCHIP], *a59[NCHIP];
      Ui4  *c0[NCHIP];
      Ui4  *c00[NCHIP], *c01[NCHIP], *c02[NCHIP], *c03[NCHIP];

      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        a0[CHIP] = A+(CHIP*M1/NCHIP+top)*L;
        a00[CHIP]= a0[CHIP]+blk+ 0; a01[CHIP]= a0[CHIP]+blk+ 1; a02[CHIP]= a0[CHIP]+blk+ 2; a03[CHIP]= a0[CHIP]+blk+ 3; a04[CHIP]= a0[CHIP]+blk+ 4; a05[CHIP]= a0[CHIP]+blk+ 5; a06[CHIP]= a0[CHIP]+blk+ 6; a07[CHIP]= a0[CHIP]+blk+ 7;
        a08[CHIP]= a0[CHIP]+blk+ 8; a09[CHIP]= a0[CHIP]+blk+ 9; a10[CHIP]= a0[CHIP]+blk+10; a11[CHIP]= a0[CHIP]+blk+11; a12[CHIP]= a0[CHIP]+blk+12; a13[CHIP]= a0[CHIP]+blk+13; a14[CHIP]= a0[CHIP]+blk+14; a15[CHIP]= a0[CHIP]+blk+15;
        a16[CHIP]= a0[CHIP]+blk+16; a17[CHIP]= a0[CHIP]+blk+17; a18[CHIP]= a0[CHIP]+blk+18; a19[CHIP]= a0[CHIP]+blk+19; a20[CHIP]= a0[CHIP]+blk+20; a21[CHIP]= a0[CHIP]+blk+21; a22[CHIP]= a0[CHIP]+blk+22; a23[CHIP]= a0[CHIP]+blk+23;
        a24[CHIP]= a0[CHIP]+blk+24; a25[CHIP]= a0[CHIP]+blk+25; a26[CHIP]= a0[CHIP]+blk+26; a27[CHIP]= a0[CHIP]+blk+27; a28[CHIP]= a0[CHIP]+blk+28; a29[CHIP]= a0[CHIP]+blk+29; a30[CHIP]= a0[CHIP]+blk+30; a31[CHIP]= a0[CHIP]+blk+31;
        a32[CHIP]= a0[CHIP]+blk+32; a33[CHIP]= a0[CHIP]+blk+33; a34[CHIP]= a0[CHIP]+blk+34; a35[CHIP]= a0[CHIP]+blk+35; a36[CHIP]= a0[CHIP]+blk+36; a37[CHIP]= a0[CHIP]+blk+37; a38[CHIP]= a0[CHIP]+blk+38; a39[CHIP]= a0[CHIP]+blk+39;
        a40[CHIP]= a0[CHIP]+blk+40; a41[CHIP]= a0[CHIP]+blk+41; a42[CHIP]= a0[CHIP]+blk+42; a43[CHIP]= a0[CHIP]+blk+43; a44[CHIP]= a0[CHIP]+blk+44; a45[CHIP]= a0[CHIP]+blk+45; a46[CHIP]= a0[CHIP]+blk+46; a47[CHIP]= a0[CHIP]+blk+47;
        a48[CHIP]= a0[CHIP]+blk+48; a49[CHIP]= a0[CHIP]+blk+49; a50[CHIP]= a0[CHIP]+blk+50; a51[CHIP]= a0[CHIP]+blk+51; a52[CHIP]= a0[CHIP]+blk+52; a53[CHIP]= a0[CHIP]+blk+53; a54[CHIP]= a0[CHIP]+blk+54; a55[CHIP]= a0[CHIP]+blk+55;
        a56[CHIP]= a0[CHIP]+blk+56; a57[CHIP]= a0[CHIP]+blk+57; a58[CHIP]= a0[CHIP]+blk+58; a59[CHIP]= a0[CHIP]+blk+59;
        c0[CHIP] = C1+(CHIP*M1/NCHIP+top)*M2;
	c00[CHIP]= (Uint*)c0[CHIP]+0; c01[CHIP]= (Uint*)c0[CHIP]+1; c02[CHIP]= (Uint*)c0[CHIP]+2; c03[CHIP]= (Uint*)c0[CHIP]+3;
      }
//EMAX5A begin mm mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-L*4)<<32|((0-M2*4)&0xffffffff); LOOP1--; INIT1=0) { /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
    /*1*/ for (INIT0=1,LOOP0=M2/W,cofs=(0-W*4)<<32|((0-W*4)&0xffffffff); LOOP0--; INIT0=0) {      /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, (W*4)<<32|(W*4), EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL);/* stage#0 */
            exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?(L*4)<<32|(M2*4):0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0, EXP_H3210, OP_AND, 0xffffffff, OP_NOP, 0LL);            /* stage#1 */
            mop(OP_LDUWR,  1, &BR[1][0][1],  (Ull)b000, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDUWR,  1, &BR[1][0][0],  (Ull)b001, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDUWR,  1, &BR[1][1][1],  (Ull)b002, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDUWR,  1, &BR[1][1][0],  (Ull)b003, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 2KB */
            mop(OP_LDUWR,  1, &BR[1][2][1],  (Ull)a00[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP); /* stage#1 16KB */

            exe(OP_FML, &AR[2][0], BR[1][0][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][1], BR[1][0][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][2], BR[1][1][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][3], BR[1][1][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            mop(OP_LDUWR,  1, &BR[2][0][1],  (Ull)b010, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 */
            mop(OP_LDUWR,  1, &BR[2][0][0],  (Ull)b011, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 */
            mop(OP_LDUWR,  1, &BR[2][1][1],  (Ull)b012, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 */
            mop(OP_LDUWR,  1, &BR[2][1][0],  (Ull)b013, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 2KB */
            mop(OP_LDUWR,  1, &BR[2][2][1],  (Ull)a01[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP);  /* stage#2 16KB */

            exe(OP_FMA, &AR[3][0], AR[2][0], EXP_H3210,  BR[2][2][1], EXP_H3210, BR[2][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FMA, &AR[3][1], AR[2][1], EXP_H3210,  BR[2][2][1], EXP_H3210, BR[2][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FMA, &AR[3][2], AR[2][2], EXP_H3210,  BR[2][2][1], EXP_H3210, BR[2][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FMA, &AR[3][3], AR[2][3], EXP_H3210,  BR[2][2][1], EXP_H3210, BR[2][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            mop(OP_LDUWR,  1, &BR[3][0][1],  (Ull)b020, (Ull)cofs, MSK_W1, (Ull)b02, M2, 0, 0, (Ull)NULL, M2);             /* stage#3 */
            mop(OP_LDUWR,  1, &BR[3][0][0],  (Ull)b021, (Ull)cofs, MSK_W1, (Ull)b02, M2, 0, 0, (Ull)NULL, M2);             /* stage#3 */
            mop(OP_LDUWR,  1, &BR[3][1][1],  (Ull)b022, (Ull)cofs, MSK_W1, (Ull)b02, M2, 0, 0, (Ull)NULL, M2);             /* stage#3 */
            mop(OP_LDUWR,  1, &BR[3][1][0],  (Ull)b023, (Ull)cofs, MSK_W1, (Ull)b02, M2, 0, 0, (Ull)NULL, M2);             /* stage#3 2KB */
            mop(OP_LDUWR,  1, &BR[3][2][1],  (Ull)a02[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP);  /* stage#3 16KB */

            exe(OP_FMA, &AR[4][0], AR[3][0], EXP_H3210,  BR[3][2][1], EXP_H3210, BR[3][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#4 */
            exe(OP_FMA, &AR[4][1], AR[3][1], EXP_H3210,  BR[3][2][1], EXP_H3210, BR[3][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#4 */
            exe(OP_FMA, &AR[4][2], AR[3][2], EXP_H3210,  BR[3][2][1], EXP_H3210, BR[3][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#4 */
            exe(OP_FMA, &AR[4][3], AR[3][3], EXP_H3210,  BR[3][2][1], EXP_H3210, BR[3][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#4 */
            mop(OP_LDUWR,  1, &BR[4][0][1],  (Ull)b030, (Ull)cofs, MSK_W1, (Ull)b03, M2, 0, 0, (Ull)NULL, M2);             /* stage#4 */
            mop(OP_LDUWR,  1, &BR[4][0][0],  (Ull)b031, (Ull)cofs, MSK_W1, (Ull)b03, M2, 0, 0, (Ull)NULL, M2);             /* stage#4 */
            mop(OP_LDUWR,  1, &BR[4][1][1],  (Ull)b032, (Ull)cofs, MSK_W1, (Ull)b03, M2, 0, 0, (Ull)NULL, M2);             /* stage#4 */
            mop(OP_LDUWR,  1, &BR[4][1][0],  (Ull)b033, (Ull)cofs, MSK_W1, (Ull)b03, M2, 0, 0, (Ull)NULL, M2);             /* stage#4 */
            mop(OP_LDUWR,  1, &BR[4][2][1],  (Ull)a03[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP);  /* stage#4 */

            exe(OP_FMA, &AR[5][0], AR[4][0], EXP_H3210,  BR[4][2][1], EXP_H3210, BR[4][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#5 */
            exe(OP_FMA, &AR[5][1], AR[4][1], EXP_H3210,  BR[4][2][1], EXP_H3210, BR[4][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#5 */
            exe(OP_FMA, &AR[5][2], AR[4][2], EXP_H3210,  BR[4][2][1], EXP_H3210, BR[4][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#5 */
            exe(OP_FMA, &AR[5][3], AR[4][3], EXP_H3210,  BR[4][2][1], EXP_H3210, BR[4][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#5 */

            mop(OP_LDUWR,  1, &BR[6][0][1],  (Ull)c00[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            mop(OP_LDUWR,  1, &BR[6][1][1],  (Ull)c01[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            mop(OP_LDUWR,  1, &BR[6][2][1],  (Ull)c02[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            mop(OP_LDUWR,  1, &BR[6][3][1],  (Ull)c03[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            exe(OP_FAD, &AR[6][0], AR[5][0], EXP_H3210,  BR[6][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */
            exe(OP_FAD, &AR[6][1], AR[5][1], EXP_H3210,  BR[6][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */
            exe(OP_FAD, &AR[6][2], AR[5][2], EXP_H3210,  BR[6][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */
            exe(OP_FAD, &AR[6][3], AR[5][3], EXP_H3210,  BR[6][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */
            mop(OP_STWR,   1, &AR[6][0],     (Ull)oofs, (Ull)c00[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            mop(OP_STWR,   1, &AR[6][1],     (Ull)oofs, (Ull)c01[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            mop(OP_STWR,   1, &AR[6][2],     (Ull)oofs, (Ull)c02[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
            mop(OP_STWR,   1, &AR[6][3],     (Ull)oofs, (Ull)c03[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#6 */
          }
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
}
#endif
